{"pages":[{"title":"关于我","text":"","link":"/about/index.html"}],"posts":[{"title":"12.02周总结","text":"API设计 问题记录 angular不使用#路由打包之后访问出现404 123456root /web/dist/;index index.html;location / { index index.html; try_files $uri $uri/ /index.html;} 左侧div跟随右侧div高度自适应 12345678&lt;div class=\"container\"&gt; &lt;div nz-row class=\"card\"&gt; &lt;div nz-col nzSpan=\"14\" class=\"logo\"&gt;&lt;/div&gt; &lt;div nz-col nzSpan=\"10\" class=\"form\"&gt; &lt;router-outlet&gt;&lt;/router-outlet&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728.container { height : 100%; width : 600px; display : flex; display : -webkit-flex; align-items: center; margin : 0 auto; .card { display : flex; width : 100%; background-color: #FFFFFF; border-radius : 5px; box-shadow : 0px 0px 25px rgba(0, 0, 0, 0.5); .form { padding: 24px 16px; } .logo { flex : 1; background-repeat : no-repeat; background-position: center center; background-size : cover; background-image : url('assets/img/logo-left.png'); } }} 这里card设置display: flex，并将logo设置flex: 1自动跟随form的高度变化","link":"/2019/12/08/12-02%E5%91%A8%E6%80%BB%E7%BB%93/"},{"title":"2020-05-12面试总结","text":"笔试题目： 实现扁平化数组 闭包与函数柯里化 1234567891011121314/** * flatten([1, [2], [3, 4], [], 5]) // [ 1, 2, 3, 4, 5 ] */function flatten(array) { const result = []; for (const item of array) { if (Array.isArray(item)) { result.push(...flatten(item)); } else { result.push(item); } } return result;} 1234567891011121314151617/** * add() // 0 * add(1) // [Function: _add] * add(1)(2)() // 3 * add(1)(2)(3, 4)() // 10 */function add() { const result = []; return (function _add() { if (arguments.length) { result.push(...arguments); return _add; } else { return result.reduce((sum, value) =&gt; sum + value, 0); } })(...arguments);}","link":"/2020/05/12/2020-05-12%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"title":"11.10周总结","text":"数据库性能优化的步骤 确定数据规模，根据经验确定正常查询所需时间 没有索引添加索引，索引是解决查询效率的第一步 通过hook监测sql执行时间，首先优化最耗时的查询 精简sql语句，只查询所需数据 延迟加载大数据字段 避免循环查询 修改表结构以匹配业务 Sqlalchemy对于JSON字段查询操作123456789# User.data = [1, 2, 3]session.query(User).filter(func.json_contains(User.data, '1'))session.query(User).filter(func.json_contains(User.data, '[1, 2]'))# User.data = {\"a\":1, \"b\": 2}session.query(User).filter(func.json_contains(User.data, '1', '$.a')) # will not raise exception if field has not attr \"a\"# User.data = {\"a\": [1, 2, 3], \"b\": 2}session.query(User).filter(func.json_contains(User.data, '[1]', '$.a')) Openresty/Nginx遇到的问题1. 后端服务处理时间太久，导致请求失败？配置超时 123456keepalive_timeout 600;client_header_timeout 600;client_body_timeout 600;proxy_connect_timeout 600;proxy_read_timeout 600;proxy_send_timeout 600; 2. 请求体过大导致webargs获取不到参数如果请求体尚未被读取，请先调用 ngx.req.read_body (或打开 lua_need_request_body 选项强制本模块读取请求体，此方法不推荐）。 如果请求体已经被存入临时文件，请使用 ngx.req.get_body_file 函数代替。 如需要强制在内存中保存请求体，请设置 client_body_buffer_size 和 client_max_body_size 为同样大小。 123client_max_body_size 5000m;client_body_buffer_size 5000m;lua_need_request_body on;","link":"/2019/11/18/11-10%E5%91%A8%E6%80%BB%E7%BB%93/"},{"title":"2020-04-28面试总结","text":"神策网络面试总结 面试题 ES6 和 CommonJS 模块管理之间的区别？ CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口 在CommonJS顶层，this指向当前模块，而在ES6模块中，this指向undefined 出现循环引用时，会有不同的现象（代码进一步实践） 居中布局如何实现？ 通用方法，元素的宽高未知 绝对定位 12345678.parent { position: relative;}.child { position: absolute; left: 50%; transform: translateX(-50%);} Flex布局 1234.parent { display: flex; justify-content: center;} 居中的元素为常规文档流中的内联元素(display: inline)，常见的内联元素有：span, a, img, input, label 等等，此方法同样适用于 display: inline-block 的元素。 123.parent { text-align: center;} 居中的元素为常规文档流中的块元素(display: block) 设置margin 123456789.parent { width: 100%;}.child { width: 600px; height: 50px; margin: 0 auto; background: #999;} 居中的元素为浮动元素 1234567.child { width: 100px; float: left; position: relative; left: 50%; margin-left: -50px;} 居中的元素为绝对定位元素 123456789.parent { position: relative;}.child { position: absolute; width: 100px; left: 50%; margin-left: -50px;} 或者 12345678910.parent { position: relative;}.child { position: absolute; width: 100px; left: 0; right: 0; margin: 0 auto;} 笔试题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;title&gt;按时间排序&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;table id=\"data\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th class=\"date\"&gt;日期&lt;/th&gt; &lt;th class=\"total\"&gt;总次数&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody id=\"body\"&gt; &lt;tr&gt; &lt;td&gt;2017年10月23日&lt;/td&gt; &lt;td&gt;68,112&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2017年8月6日&lt;/td&gt; &lt;td&gt;68,020&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2017年11月11日&lt;/td&gt; &lt;td&gt;69,433&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2016年5月12日&lt;/td&gt; &lt;td&gt;69,699&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2017年1月18日&lt;/td&gt; &lt;td&gt;42,565&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;script&gt; window.onload = () =&gt; { // 题目一：按照时间排序 const dateTitle = document.getElementsByClassName(\"date\")[0]; const totalTitle = document.getElementsByClassName(\"total\")[0]; const tbody = document.getElementById(\"body\"); const trListByDate = sortFunc( [...tbody.children], (a, b) =&gt; digestDateString(a.children[0].innerText) &lt; digestDateString(b.children[0].innerText) ); dateTitle.addEventListener(\"click\", () =&gt; { clearChildren(tbody); trListByDate.reverse(); trListByDate.forEach((tr) =&gt; tbody.appendChild(tr)); }); const trListByTotal = sortFunc( [...tbody.children], (a, b) =&gt; a.children[1].innerText &lt; b.children[1].innerText ); totalTitle.addEventListener(\"click\", () =&gt; { clearChildren(tbody); trListByTotal.reverse(); trListByTotal.forEach((tr) =&gt; tbody.appendChild(tr)); }); // 题目二：分解因式 console.log(calc(30)); }; function clearChildren(element) { while (element.lastChild) { element.removeChild(element.lastChild); } } function sortFunc(trList, compareFunc) { const len = trList.length; for (let i = 0; i &lt; len; i++) { for (let j = 0; j &lt; len - 1 - i; j++) { if ( compareFunc ? compareFunc(trList[j], trList[j + 1]) : trList[j] &gt; trList[j + 1] ) { const tmp = trList[j]; trList[j] = trList[j + 1]; trList[j + 1] = tmp; } } } return trList; } function digestDateString(dateString) { const year = getYear(dateString); let month = getMonth(dateString); let day = getDay(dateString); if (month.length &lt; 2) { month = \"0\" + month; } if (day.length &lt; 2) { day = \"0\" + day; } return `${year}年${month}月${day}日`; } function getYear(dateString) { return dateString.split(\"年\")[0]; } function getMonth(dateString) { return dateString.split(\"年\")[1].split(\"月\")[0]; } function getDay(dateString) { return dateString.split(\"月\")[1].split(\"日\")[0]; } function calc(n) { const result = []; for (let i = 2; i &lt; n; i++) { if (n % i === 0) { n = n / i; result.push(i); i = 1; } } result.push(n); return result; } &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","link":"/2020/04/28/2020-04-28%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"},{"title":"Pixi-in-Depth","text":"pixi.js 部分源码解析 初始化应用Application 主要完成以下任务： 构建舞台 stage 作为渲染数据 构建渲染器 renderer 渲染 stage 依次调用 plugins 的 init 方法 暴露 render 方法，渲染一帧 packages/app/src/Application.ts 1234567891011121314class Application{ public stage: Container = new Container(); constructor { this.renderer = autoDetectRenderer(options); Application._plugins.forEach((plugin) =&gt; { plugin.init.call(this, options); }); } render() { this.renderer.render(this.stage); }} 构建渲染循环Application 通过调用 registerPlugin 往静态属性 _plugins 数组中存入插件 其中一个名为 TickerPlugin 的插件，用来专门处理 GameLoop bundles/pixi.js/src/index.ts 1Application.registerPlugin(TickerPlugin); 进入 TickerPlugin 的 init 方法可以发现 Ticker 绑定了 render 方法 packages/ticker/src/TickerPlugin.ts 1234// this 指向 Application 实例if (ticker) { ticker.add(this.render, this, UPDATE_PRIORITY.LOW);} 在探究 ticker.add 之前，先理解一下什么是 GameLoop，如果你使用过 canvas 绘制动画，对下面的代码一定不陌生： 1234(function tick() { requestAnimationFrame(tick); // animate})(); The window.requestAnimationFrame() method tells the browser that you wish to perform an animation and requests that the browser calls a specified function to update an animation before the next repaint. The method takes a callback as an argument to be invoked before the repaint. requestAnimationFrame 类似 setTimeout，tick 不断异步递归自己，相当于带间隔的死循环，每一帧调用，触发浏览器重绘 Ticker 做了类似的事情，只是额外增加了一些功能： 维护了任务队列，可以按优先级排序 过滤或取消多余的绘制请求，防止过载 绑定回调自动启动渲染循环（autoStart===true） 提供 add 和 addOnce 来实现每次和单次执行 帧率控制，优化渲染最小帧率和最大帧率范围 Ticker 在构造函数中创建了 _tick 作为每一帧的回调函数 packages/ticker/src/Ticker.ts 12345678910this._tick = (time: number): void =&gt; { this._requestId = null; if (this.started) { this.update(time); if (this.started &amp;&amp; this._requestId === null &amp;&amp; this._head.next) { this._requestId = requestAnimationFrame(this._tick); } }}; started 用于控制渲染循环的运行和退出 _head 以链表的方式组织所有回调任务 _requestId 来标记正在进行的渲染请求 回调任务通过 add 和 addOnce 插入链表，它们都调用 _addListener 方法，只是构建的 TickerListener 传入参数有所区分 packages/ticker/src/Ticker.ts 1234567add&lt;T = any&gt;(fn: TickerCallback&lt;T&gt;, context?: T, priority = UPDATE_PRIORITY.NORMAL): this { return this._addListener(new TickerListener(fn, context, priority));}addOnce&lt;T = any&gt;(fn: TickerCallback&lt;T&gt;, context?: T, priority = UPDATE_PRIORITY.NORMAL): this { return this._addListener(new TickerListener(fn, context, priority, true));} _addListener 通过遍历 _head 之后每个节点的 priority 属性来确定插入位置 packages/ticker/src/Ticker.ts 1234567891011121314let current = this._head.next;let previous = this._head;while (current) { if (listener.priority &gt; current.priority) { listener.connect(previous); break; } previous = current; current = current.next;}if (!listener.previous) { listener.connect(previous);} TickerListener.connect 实现了链表插入 packages/ticker/src/TickerListener.ts 12345678connect(previous: TickerListener): void { this.previous = previous; if (previous.next) { previous.next.previous = this; } this.next = previous.next; previous.next = this;} 在 Ticker.update 方法中会遍历回调任务链表，依次调用 TickerListener.emit packages/ticker/src/Ticker.ts 1234567const head = this._head;let listener = head.next;while (listener) { listener = listener.emit(this.deltaTime);} 在 TickerListener.emit 执行回调函数，并返回下一个节点 addOnce 会将 TickerListener.once 标记为 true，执行一次后会从链表中删除 packages/ticker/src/TickerListener.ts 1234567891011121314151617emit(deltaTime: number): TickerListener { if (this.fn) { if (this.context) { this.fn.call(this.context, deltaTime); } else { (this as TickerListener&lt;any&gt;).fn(deltaTime); } } const redirect = this.next; if (this.once) { this.destroy(true); } return redirect;} Ticker.update 还存在一段逻辑用于控制帧率逻辑，不过有点混乱，暂时略过 构建舞台树初始化 Application 默认会创建 stage 作为舞台的根容器，之后所有需要渲染的对象都需要存储到它或它下属节点的 children 属性中，形成一颗舞台树 常见的方式是通过 addChild 把一个对象 push 到 Container.children 中 12const g = new PIXI.Graphics();stage.addChild(g); Graphics 本身也是 Container，所以可以在它的下面继续挂载节点 舞台上所有的对象以树形结构组织，渲染很自然变成了遍历整颗树，然后依次绘制每个物体的过程 每一个物体的绘制可以简单分为两部分（类似 DOM 绘制过程中的重排和重绘），一找到绘制的位置，二调用 API 绘制图像 对于第一个需求，每个对象可以从当前位置向上遍历至根节点，依次计算它们相对位置影响的总和，比如 12345 A 向x偏移10 / \\ 向x偏移-10 B C向y偏移-10 | | 向y偏移10 D F 如果将 A 坐标系设为全局坐标系，原点为(0, 0)，D 遍历 D-&gt;B-&gt;A，得到 D 坐标系原点在 A 中为(10, -10)，A 原点在 D 中表示则为(-10, 10) 如果每个物体都这样计算，效率是极低的，况且很多时候 D 单独变化时，B-&gt;A 根本没变化，优化的思路就是为每一层级添加缓存 12345 A(0, 0) 向x偏移10 / \\ 向x偏移-10 (10, 0)B C(-10, 0)向y偏移-10 | | 向y偏移10 (10, -10)D F(-10, 10) 如果 D 此时相对与父节点不是向 y 偏移 -10 而是向 y 偏移 10，那么可以很容易根据 B(10, 0) 重新计算得到 D(10, 10) 这样做还有一个优势就是非常容易的实现坐标在不同坐标系中的转换： 假设 D 中有个点 P1(1, 1)，可以计算得到 P1 在 A 中的坐标为(11, -9) 假设 A 中有个点 P2(2, 2)，可以计算得到 P2 在 D 中的坐标为(-8, 12) Pixi 也是类似的思路，DisplayObject 上就有 Transform 对象负责管理和缓存位置变换信息，可以找到两个重要属性 packages/math/src/Transform.ts 12public worldTransform: Matrix;public localTransform: Matrix; 对于 worldTransform 就类似 D 相对 A 的位置偏移(10, -10)，而 localTransform 就类似 向y偏移-10 可以表示为(0, -10) 节点的 worldTransform 总是通过它的父节点的 worldTransform 和它自己 localTransform 一起计算得到 缓存有了，何时更新缓存又是一个大问题！别着急，看看代码发现了几个计数器 packages/math/src/Transform.ts 1234public _parentID: number;_worldID: number; // =&gt; _currentParentIDprotected _localID: number;protected _currentLocalID: number; Pixi 通过计数器来确定上层或本层是否发生改变，本层或下层是否需要更新，四个计数器成队出现，两两比较值是否相等 packages/math/src/Transform.ts 1234567891011121314151617181920212223242526272829303132updateTransform(parentTransform: Transform): void { const lt = this.localTransform; if (this._localID !== this._currentLocalID) { lt.a = this._cx * this.scale.x; lt.b = this._sx * this.scale.x; lt.c = this._cy * this.scale.y; lt.d = this._sy * this.scale.y; lt.tx = this.position.x - ((this.pivot.x * lt.a) + (this.pivot.y * lt.c)); lt.ty = this.position.y - ((this.pivot.x * lt.b) + (this.pivot.y * lt.d)); this._currentLocalID = this._localID; this._parentID = -1; } if (this._parentID !== parentTransform._worldID) { const pt = parentTransform.worldTransform; const wt = this.worldTransform; wt.a = (lt.a * pt.a) + (lt.b * pt.c); wt.b = (lt.a * pt.b) + (lt.b * pt.d); wt.c = (lt.c * pt.a) + (lt.d * pt.c); wt.d = (lt.c * pt.b) + (lt.d * pt.d); wt.tx = (lt.tx * pt.a) + (lt.ty * pt.c) + pt.tx; wt.ty = (lt.tx * pt.b) + (lt.ty * pt.d) + pt.ty; this._parentID = parentTransform._worldID; this._worldID++; }} 当前节点的 _localID 和当前节点的 _currentLocalID 配对，每当修改了位置状态，使 _localID 自增，以更新 localTransform，更新完成同步 _localID 和 _currentLocalID，并使当前节点的 _parentID 为 -1，以便继续更新当前节点的 worldTransform 当前节点的 _parentID 和上层节点的 _worldID 配对，如果不相等，更新当前节点的 worldTransform，同步当前节点的 _parentID 和上层节点的 _worldID，自增当前节点的 _worldID，以便继续更新下层节点的 worldTransform 回到添加物体到舞台的过程，查看 addChild 源码 packages/display/src/Container.ts 12345678910if (child.parent) { child.parent.removeChild(child);}child.parent = this;this.sortDirty = true;child.transform._parentID = -1;this.children.push(child); 除了 push 到 children 数组，额外的工作就是设置 transform._parentID 为 -1，以便在渲染循环中更新变换矩阵 更新发生在每一帧都会调用的 Renderer.render 方法中，skipUpdateTransform 默认为 undefined packages/core/src/Renderer.ts 123456if (!skipUpdateTransform) { const cacheParent = displayObject.enableTempParent(); displayObject.updateTransform(); displayObject.disableTempParent(cacheParent);} 对于普通 DisplayObject 对象，updateTransform 仅仅更新它自己的状态 packages/display/src/DisplayObject.ts 12345updateTransform(): void { // ... this.transform.updateTransform(this.parent.transform);} 但是对于 Container 对象，继承 DisplayObject 重写了 updateTransform 方法 packages/display/src/Container.ts 12345678910111213updateTransform(): void { // ... this.transform.updateTransform(this.parent.transform); for (let i = 0, j = this.children.length; i &lt; j; ++i) { const child = this.children[i]; if (child.visible) { child.updateTransform(); } }} Container.updateTransform 方法以深度优先顺序调用，更新所有受到影响的下属节点 舞台树所有节点的位置信息准备就绪，开始绘制！ 渲染到画布待舞台树位置更新完成后，会开始绘制 packages/core/src/Renderer.ts 12345678if (!skipUpdateTransform) { const cacheParent = displayObject.enableTempParent(); displayObject.updateTransform(); displayObject.disableTempParent(cacheParent);}displayObject.render(this); DisplayObject.render 是一个抽象方法，并没有实现，查看 Container.render 的实现 packages/display/src/Container.ts 12345678910111213render(renderer: Renderer): void { // ... if (/* */) { // ... } else { this._render(renderer); for (let i = 0, j = this.children.length; i &lt; j; ++i) { this.children[i].render(renderer); } }} Container.render 也是以深度优先顺序调用，具体过程由子类的 _render 方法实现 Graphics 继承于 Container，以它举例，定位到 Graphics._render 方法 packages/graphics/src/Graphics.ts 12345678910111213141516171819202122 protected _render(renderer: Renderer): void { this.finishPoly(); const geometry = this._geometry; const hasuint32 = renderer.context.supports.uint32Indices; geometry.updateBatches(hasuint32); if (geometry.batchable) { if (this.batchDirty !== geometry.batchDirty) { this._populateBatches(); } this._renderBatched(renderer); } else { renderer.batch.flush(); this._renderDirect(renderer); }} geometry.batchable 等于 true 为批处理逻辑，是为了提升性能做的优化，先不管这个分支，之后研究批处理系统时再深入 进入 Graphics._renderDirect 方法 packages/graphics/src/Graphics.ts 123456789101112protected _renderDirect(renderer: Renderer): void { // ... renderer.shader.bind(shader); renderer.geometry.bind(geometry, shader); renderer.state.set(this.state); for (let i = 0, l = drawCalls.length; i &lt; l; i++) { this._renderDrawCallDirect(renderer, geometry.drawCalls[i]); }} 可以看到 renderer 绑定了 shader 和 geometry，还设置了状态，内部已经为开始绘制准备好了 WebGL 上下文 gl，现在只需根据生成的 drawCall 依次绘制即可，暂时忽略调用 WebGL API 绘制的过程，之后分析 Renderer 封装时详细研究 由于 geometry.drawCalls 和渲染的图形息息相关，为了查看它的信息，起了一个 demo，仅仅绘制一条线 demo.ts 123456789101112131415161718192021import \"./index.scss\";import * as PIXI from \"pixi.js\";const container = document.querySelector(\"#root\")! as HTMLDivElement;const { renderer, stage, ticker } = new PIXI.Application({ backgroundColor: 0xf3f3f3, autoDensity: true, resolution: window.devicePixelRatio, antialias: true, autoStart: true, resizeTo: container,});container.append(renderer.view);const g = new PIXI.Graphics();stage.addChild(g);g.lineStyle(1);g.moveTo(0, 0);g.lineTo(100, 100);","link":"/2021/03/28/Pixi-in-Depth/"},{"title":"WSL配置指南","text":"以管理员启动控制台，执行Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux 在应用商店安装Ubuntu 18.04和Windows Terminal，配置Ubuntu 18.04为默认终端 打开Windows Terminal控制台连接Ubuntu 18.04，输入用户名和密码，执行sudo passwd root设置管理员密码 修改/etc/sudoers使sudo不再需要密码 1234567sudo chmod u+w /etc/sudoerssudo vim /etc/sudoers# - %sudo ALL=(ALL:ALL) ALL# + %sudo ALL=(ALL:ALL) NOPASSWD:ALLsudo chmod u-w /etc/sudoers 更换apt源，清华源地址：https://mirror.tuna.tsinghua.edu.cn/help/ubuntu/ 执行sudo apt update和sudo apt upgrade -y（此过程较为耗时，耐心等待） 安装oh-my-zsh 12345678910111213141516# 安装zshsudo apt install zsh -y# 配置zshchsh -s /bin/zsh# 确认配置成功echo $SHELL# 重新打开终端以生效，选择2# 由于网络的原因，在浏览器打开脚本 https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh 复制# 在终端中创建一个.sh文件，不要使用.txt修改后缀的方式，不然脚本执行有问题touch oh-my-zsh.shchmod u+x oh-my-zsh.shsh oh-my-zsh.sh 安装oh-my-zsh相关插件 autojump 1234git clone git://github.com/wting/autojump.git# 如果没有python# sudo apt install python -ycd autojump &amp;&amp; ./install.py 接着拷贝以下代码到 ~/.zshrc 末尾 12[[ -s /home/wenjun/.autojump/etc/profile.d/autojump.sh ]] &amp;&amp; source /home/wenjun/.autojump/etc/profile.d/autojump.shautoload -U compinit &amp;&amp; compinit -u zsh-autosuggestions 1git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions 在 ~/.zshrc 中添加 1234plugins=( ... zsh-autosuggestions) zsh-syntax-highlighting 1git clone git://github.com/zsh-users/zsh-syntax-highlighting $ZSH_CUSTOM/plugins/zsh-syntax-highlighting 在 ~/.zshrc 中添加 1234plugins=( ... zsh-syntax-highlighting) 执行compaudit | xargs chmod g-w,o-w修复不安全的脚本执行 安装node及npm 123456789101112131415161718192021222324# 安装nodesudo apt install nodejs -y# 安装npmsudo apt install npm -y# 配置淘宝源sudo npm config set registry https://registry.npm.taobao.org# 修改权限echo $(npm config get prefix)sudo chown -R $(whoami) &lt;path&gt;# 升级npm到最新sudo npm install -g npm@latest# 安装n模块sudo npm install -g n# 清空缓存sudo npm cache clean -f# 升级node为稳定版sudo n stable 执行ssh-keygen -o以生成ssh密钥，cat ~/.ssh/id_rsa.pub查看公钥，在GitLab中添加公钥以访问代码库","link":"/2020/04/20/WSL%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/"},{"title":"MacOS上的必备工具","text":"Homebrew包管理工具（类似ubuntu下的apt，centos下的yum），可以用来安装和管理许多开发过程中使用到的软件和工具，自动配置，会节省很多配置环境的时间。 使用也非常简单，例如安装pipenv： 1brew install pipenv Item2更好有的终端，完爆mac自带的 Oh-my-zsh更好的shell命令支持 推荐几个oh-my-zsh的插件 zsh-autosuggestions 自动提示输入过的命令 zsh-syntax-highlighting shell命令语法高亮，如果命令错误会显示为红色 autojump 快速跳转目录 git-open 快速打开远程仓库 Alfred提供快速应用打开和文件访问以及workflow功能，我心中的mac神器，没有之一，直接入手了最高版。虽然一开始你会觉得有一点小贵，但是使用过程中你会发现它真值，提高了一半的工作效率。 Magnet (Appstore)窗口布局工具。macos上没有类似windows上通过win+上下左右布局窗口的内置功能，所以需要其他工具实现。这款工具使用简单，不需要配置，安装即用。 Manico (Appstore)应用快速切换工具 QSpace (Appstore)比Finder更强大的资源管理器 可以通过设置打开item2终端和vscode编辑器 Microsoft To Do (Appstore)简洁的代办事项提醒 未完待续","link":"/2019/11/01/macos%E4%B8%8A%E7%9A%84%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7/"},{"title":"tcp三次握手和四次挥手","text":"文章链接 创建一个简单的服务1234567891011121314import http from 'http';const server = http.createServer( (req: http.IncomingMessage, res: http.ServerResponse) =&gt; { console.log(`${req.method} ${req.url}`); res.write('Hello World!'); res.end(); },);const host = 'localhost';const port = 4000;console.log(`Start server on ${host}:${port}`);server.listen(port, host); 启动服务，并监视文件改变以重启服务 1234567➜ npm run start:dev&gt; create-custom-operators-in-rxjs@1.0.0 start:dev /Users/defpis/Workspace/all-about-http-that-you-should-know&gt; tsnd --respawn --transpileOnly ./srcUsing ts-node version 8.8.1, typescript version 3.8.3Start server on localhost:4000 使用命令测试访问 12➜ curl http://localhost:4000Hello World!· 使用 Wireshark 抓包打开 Wireshark，在过滤器中输入 host 127.0.0.1 and port 4000，选择 Loopback: Io0（本地环回接口）以监测流量。 使用 curl 命令发送请求，然后查看 Wireshark 面板，可以看到完整的网络连接与断开过程 点击一个连接，可以查看连接的详细信息，从上到下分为 frame：链路层封装 null：无 ip：网络层封装 tcp：传输层封装 点开 tcp 传输层封包信息 12345678910111213141516171819Transmission Control Protocol, Src Port: 51428, Dst Port: 4000, Seq: 0, Len: 0 Source Port: 51428 Destination Port: 4000 [Stream index: 1] [TCP Segment Len: 0] Sequence number: 0 (relative sequence number) Sequence number (raw): 2901135694 [Next sequence number: 1 (relative sequence number)] Acknowledgment number: 0 Acknowledgment number (raw): 0 1011 .... = Header Length: 44 bytes (11) Flags: 0x002 (SYN) Window size value: 65535 [Calculated window size: 65535] Checksum: 0xfe34 [unverified] [Checksum Status: Unverified] Urgent pointer: 0 Options: (24 bytes), Maximum segment size, No-Operation (NOP), Window scale, No-Operation (NOP), No-Operation (NOP), Timestamps, SACK permitted, End of Option List (EOL) [Timestamps] 首先关注 Flags，把它展开可以得到 123456789101112Flags: 0x002 (SYN) 000. .... .... = Reserved: Not set ...0 .... .... = Nonce: Not set .... 0... .... = Congestion Window Reduced (CWR): Not set .... .0.. .... = ECN-Echo: Not set .... ..0. .... = Urgent: Not set .... ...0 .... = Acknowledgment: Not set .... .... 0... = Push: Not set .... .... .0.. = Reset: Not set .... .... ..1. = Syn: Set .... .... ...0 = Fin: Not set [TCP Flags: ··········S·] 显而易见，像 SYN、ACK 或 FIN 这些符号其实都是二进制的标志位 符号 十六进制 二进制 阶段 [SYN] 0x002 000,000,000,010 第一次握手 [SYN, ACK] 0x012 000,000,010,010 第二次握手 [ACK] 0x010 000,000,010,000 第三次握手，第二次挥手，第四次挥手 [FIN, ACK] 0x011 000,000,010,001 第一次挥手，第三次挥手 除此之外，tcp 封包中还包含用于验证的字段 字段 全称 作用 Seq/tcp.seq Sequence number 表示曾经发送过数据的字节数+1，0 表示之前没有发送过数据 Ack/tcp.ack Acknowledgment number 表示期待下次对方发送过来的 Seq 的值 理解清楚这些概念就可以开始分析 tcp 连接建立的过程——三次握手。 三次握手 客户端：服务器你好，我需要建立连接（第一次握手请求） 服务端：收到（第一次握手响应），正在准备，请确认连接（第二次握手请求） 客户端：收到（第二次握手响应），确认连接（第三次握手请求，服务端收到响应） 四次挥手 客户端：服务器你好，我需要断开连接（第一次挥手请求） 服务端：收到（第一次挥手响应），正在准备（第二次挥手请求，客户端收到响应） 服务端：已准备好断开连接，请确认断开（第三次挥手请求） 客户端：收到（第三次挥手响应），确认断开（第四次挥手请求，服务端收到响应）","link":"/2020/04/24/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"},{"title":"Angular-ProvidedIn","text":"","link":"/2020/04/01/Angular-ProvidedIn/"},{"title":"zonejs原理解析","text":"至从接触了Angualr2+之后，就从各种博客中了解到Angular2+使用了zone.js追踪异步操作，通过类似某些语言中本地线程存储(thread-local storage)的方式，在任意异步操作中访问相同数据。 作为之前的Flask重度开发者，本地线程存储这个概念并不陌生，Flask中的current_app, request, g对象等都是通过Werkzeug包提供的LocalStack和LocalProxy实现了本地线程存储，对比Django在视图函数中传递请求上下文对象无疑更加优雅。 但是它们之间也有一些区别：Flask实现了上下文在不同线程之间的切换；zone.js实现了上下文在异步代码中的持久化传递。 为了探究zone.js的实现，我阅读了v0.1.0版本的源码，从中窥探到了一些核心原理，通过下面构建simple-zone示例分享给大家。 首先根据Minimal TypeScript setup for curious minds这篇文章构建一个TypeScript的最小开发环境 123456789.├── README.md├── node_modules├── package-lock.json├── package.json├── src│ └── index.ts├── test└── tsconfig.json 12// src/index.tsconsole.log('Hello World!'); 123➜ npm run serveHello World! 这样环境就算搭建好了 开始构建zone.js，首先它一定是一个class对象，可以传递父zone来构建，也可以传递一些配置，额外绑定一个静态属性index来标识创建的zone实例。 123456789101112131415161718class Zone { // 标识创建的zone实例 static index = 0; constructor(public parentZone: Zone | null = null, public ZoneSpec = {}) { // 如果传递了parentZone，以parentZone为原型对象创建空对象 const zone = parentZone ? Object.create(parentZone) : this; zone.index = ++Zone.index; zone.parentZone = parentZone; Object.keys(ZoneSpec).forEach(key =&gt; { zone[key] = ZoneSpec[key]; }) return zone; }}const rootZone = new Zone();console.log(rootZone); // =&gt; Zone { parentZone: null, ZoneSpec: {}, index: 1 } 然后实现各个基础方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 在node中执行，全局对象为globalconst g: { [key: string]: any } = global;class Zone{ // ... // 以当前zone实例为原型，构造一个新的zone fork(spec = {}) { return new Zone(this, spec); } // 切换上下文执行回调函数 run( fn: { apply: (arg0: any, arg1: any) =&gt; any }, applyTo: any, applyWith: IArguments, ): any { const oldZone = g.zone; g.zone = this; let result; try { if (g.zone.onEnter) { g.zone.onEnter(); } result = fn.apply(applyTo, applyWith); } catch (e) { console.error(e); } finally { if (g.zone.onLeave) { g.zone.onLeave(); } g.zone = oldZone; } return result; } // 使用zone包裹函数执行 bind(fn: {apply: (arg0: any, arg1: any) =&gt; any}) { // 闭包了一个与同步执行顺序有关的zone实例 const zone = this.fork(); return function ZoneBoundFn(this: Zone): any { return zone.run(fn, this, arguments); }; }}// 绑定rootZone到全局const rootZone = (g.zone = new Zone());console.log(rootZone); 接下来就是zone.js黑科技的地方了，通过patch global.settimeout举例 123456789101112131415161718192021222324252627282930313233class Zone{ // 修改异步函数(eg: settimeout)的回调函数 // 使异步回调函数被当前g.zone包裹执行 static bindArguments(args: IArguments) { for (let i = args.length - 1; i &gt;= 0; i--) { if (typeof args[i] === 'function') { args[i] = g.zone.bind(args[i]); } } return args; } static patchFn(obj: any, fnNames: any) { fnNames.forEach((name: string) =&gt; { // 使原有的方法在zone下执行 // 并且收集方法到rootZone const delegate = obj[name]; if (delegate) { g.zone[name] = function () { return delegate.apply(obj, Zone.bindArguments(arguments)) } obj[name] = function () { return g.zone[name].apply(this, arguments); } } }); }}// 保存原始setTimeoutconst _setTimeout = g.setTimeout;// 替换为zone执行的方法Zone.patchFn(g, ['setTimeout']); 最后通过我们实现的Zone来统计一下多个异步任务的总执行时间 12345678910111213141516171819202122232425262728293031323334353637let totalTime = 0;const zoneA: any = rootZone.fork({ onEnter() { this.startTime = new Date().getTime(); }, onLeave() { const time = (new Date()).getTime() - this.startTime console.log(`Took: ${time}ms`); totalTime += time; }});function main() { console.log('start...'); setTimeout(() =&gt; { workFn('work1'); setTimeout(() =&gt; { workFn('work2'); setTimeout(() =&gt; { workFn('work3'); }, 1000) }, 1000) }, 1000); _setTimeout(() =&gt; { console.log(`totalTime: ${totalTime}ms`); }, 5000); function workFn(msg: string) { console.log(msg); new Array(1000000).forEach(n =&gt; { Math.sqrt(n); }) }}zoneA.run(main); 执行得到 1234567891011➜ npm run servestart...Took: 2mswork1Took: 14mswork2Took: 14mswork3Took: 20mstotalTime: 50ms 总结：通过闭包和原型链的使用关联了同步和异步代码，持久化传递了执行上下文。 本文源码：https://github.com/defpis/zonejs-analysis","link":"/2020/03/17/zonejs%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"},{"title":"promise在angular1.x中的实现","text":"angular1.x 中实现 Promise 由两部分组成 Deferred 和 Promise。如果 Promise 承诺将来会提供某些值，那么 Deferred 就是使该值可用的计算过程。两者总是成对出现，但是通常可以被代码的不同部分访问。 从数据流的角度来考虑它，则数据的生产者有一个 Deferred，而数据的使用者有一个 Promise。在未来的某个时刻，当生产者计算出了数据时，消费者将获得 Promise 的值。 angular1.x 使用 $rootScope.$evalAsync 来在整理周期内处理 Promise，这里仅仅通过 setTimeout 来延迟评估价值。 源码仓库：https://github.com/defpis/promise-in-angular1.x 实现：src/promise.ts 测试：test/promise.spec.ts 实现参考了《build-your-own-angularjs》，以 TypeScript 重新实现。","link":"/2020/03/24/promise%E5%9C%A8angular1-x%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"title":"使用RxJS实现快捷键","text":"项目中经常需要实现快捷键功能，通过 RxJS 可以很容易实现！ 首先拦截所有键盘事件 12345678import { fromEvent, merge } from \"rxjs\";const keyDown$ = fromEvent&lt;KeyboardEvent&gt;(document.body, \"keydown\");const keyUp$ = fromEvent&lt;KeyboardEvent&gt;(document.body, \"keyup\");const keyAction$ = merge(keyDown$, keyUp$);keyAction$.subscribe((event) =&gt; console.log(event.key, event.type)); 对于任意按键的 down 和 up 都会触发 console.log 12345z keydownz keyupx keydownx keyup... 测试发现一个问题，按住按键不放会一直触发 down 事件，解决只需用 distinctUntilChanged 去重即可，当然为了共享流，还需要添加 share 操作符 123456const isSameKey = (a: KeyboardEvent, b: KeyboardEvent): boolean =&gt; a.code === b.code &amp;&amp; a.type === b.type;const keyAction$ = merge(keyDown$, keyUp$).pipe( distinctUntilChanged(isSameKey), share()); 一般快捷键要求同时按下组合键来生效，例如 C-x 等于先按住 Control，再按住 x，相当于同时检测两个流，两个流的最新 event.code 都为预期值时，触发效果 于是可以定义一个数组 keyCodes，数组中的每个 keyCode 就是要同时按住的按键。通过 map 获取一个流数组，每个流仅当 keyCode 匹配时流动 1234const keyCodes = [\"ControlRight\", \"KeyX\"];const observables = keyCodes.map((keyCode) =&gt; keyAction$.pipe(filter((event) =&gt; event.code === keyCode))); 然后使用 combineLatest 合并每个流的最新值，保证它们都是按下的情况，触发合并流 123const isAllKeyDown = (events: KeyboardEvent[]): boolean =&gt; events.every((event) =&gt; event.type === \"keydown\");const C_x$ = combineLatest(observables).pipe(filter(isAllKeyDown)); 得到的 C_x$ 就是同时按下 Control 和 x 的流 测试又发现一个问题，同时按下不存在顺序，先按 x 再按 Control 也能触发流，希望避免这种情况 可以再定一个操作符来过滤顺序不正确的情况 1234567891011121314const keepOrder = () =&gt; (source: Observable&lt;KeyboardEvent[]&gt;) =&gt; source.pipe( filter((events) =&gt; { const sortedSeq = events .slice() .sort((a, b) =&gt; a.timeStamp - b.timeStamp) .map((event) =&gt; event.code) .join(); const originalSeq = events.map((event) =&gt; event.code).join(); return sortedSeq === originalSeq; }) );const C_x$ = combineLatest(observables).pipe(filter(isAllKeyDown), keepOrder()); But 不知道怎么回事 Control 始终会触发两次，导致保顺失败，换成其他字母按键没有问题。 所有代码如下： 123456789101112131415161718192021222324252627282930313233343536import { combineLatest, fromEvent, merge, Observable } from \"rxjs\";import { distinctUntilChanged, filter, share } from \"rxjs/operators\";const keyDown$ = fromEvent&lt;KeyboardEvent&gt;(document.body, \"keydown\");const keyUp$ = fromEvent&lt;KeyboardEvent&gt;(document.body, \"keyup\");const isSameKey = (a: KeyboardEvent, b: KeyboardEvent): boolean =&gt; a.code === b.code &amp;&amp; a.type === b.type;const keyAction$ = merge(keyDown$, keyUp$).pipe( distinctUntilChanged(isSameKey), share());const keyCodes = [\"KeyX\", \"KeyY\", \"KeyZ\"];const observables = keyCodes.map((keyCode) =&gt; keyAction$.pipe(filter((event) =&gt; event.code === keyCode)));const isAllKeyDown = (events: KeyboardEvent[]): boolean =&gt; events.every((event) =&gt; event.type === \"keydown\");const keepOrder = () =&gt; (source: Observable&lt;KeyboardEvent[]&gt;) =&gt; source.pipe( filter((events) =&gt; { const sortedSeq = events .slice() .sort((a, b) =&gt; a.timeStamp - b.timeStamp) .map((event) =&gt; event.code) .join(); const originalSeq = events.map((event) =&gt; event.code).join(); return sortedSeq === originalSeq; }) );const xyz$ = combineLatest(observables).pipe(filter(isAllKeyDown), keepOrder());xyz$.subscribe(() =&gt; console.log(\"x y z\"));","link":"/2021/02/09/%E4%BD%BF%E7%94%A8RxJS%E5%AE%9E%E7%8E%B0%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"title":"偶然看到的面试题","text":"","link":"/2020/04/14/%E5%81%B6%E7%84%B6%E7%9C%8B%E5%88%B0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"title":"分片上传文件","text":"问题出处：https://juejin.im/post/5dff8a26e51d4558105420ed 服务端实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102from flask import Flask, jsonify, send_file, Blueprintfrom werkzeug.datastructures import FileStoragefrom parser import parse, fieldsfrom pathlib import Pathimport shutilROOT_PATH: Path = Path(__file__).parents[0]UPLOAD_DIR: Path = ROOT_PATH / 'upload'if not UPLOAD_DIR.exists(): UPLOAD_DIR.mkdir()app: Flask = Flask(__name__)api_bp: Blueprint = Blueprint('api', __name__, url_prefix='/api')@app.route('/')def hello_world(): return 'Hello World!'@api_bp.route('/ping')def ping(): return jsonify('pong')@api_bp.route('/upload/normal', methods=['POST'])@parse({ 'file': fields.Raw(required=True)}, location='form_data')def upload_normal(args): file_path: Path = UPLOAD_DIR / args['file'].filename if not file_path.exists(): print('save...') args['file'].save(file_path) return jsonify(msg='ok')@api_bp.route('/upload/chunk', methods=['POST'])@parse({ 'name': fields.Str(required=True), 'chunk': fields.Raw(required=True)}, location='form_data')def upload_chunk(args): dir_path: Path = UPLOAD_DIR / f\"{args['name']}\" if not dir_path.exists(): dir_path.mkdir() chunk: FileStorage = args['chunk'] file_path: Path = dir_path / chunk.filename if not file_path.exists(): print('save...') chunk.save(file_path) return jsonify(msg='ok')@api_bp.route('/upload/combine', methods=['POST'])@parse({ 'name': fields.Str(required=True),}, location='form_data')def upload_combine(args): dir_path: Path = UPLOAD_DIR / args['name'] if not dir_path.exists(): return jsonify(msg='Not Found'), 404 tmp_path = Path(f'{dir_path}#tmp') dir_path.rename(tmp_path) with open(dir_path, 'wb+') as f1: for chunk_path in sorted(tmp_path.iterdir()): print(chunk_path) with open(chunk_path, 'rb') as f2: f1.write(f2.read()) shutil.rmtree(tmp_path) return jsonify(msg='ok')@api_bp.route('/upload/progress', methods=['POST'])@parse({ 'name': fields.Str(required=True),}, location='form_data')def upload_progress(args): dir_path: Path = UPLOAD_DIR / args['name'] # 不存在，进度为0% if not dir_path.exists(): return jsonify(progress=[]) # 如果已经合并为一个文件，进度为100% if dir_path.is_file(): return jsonify(progress='finished') # 返回已上传的分片列表 return jsonify(progress=[int(chunk_path.name.split('-')[-1]) for chunk_path in dir_path.iterdir() if chunk_path.is_file()])@api_bp.route('/download/&lt;string:name&gt;')def download(name: str): file_path = UPLOAD_DIR / name if not file_path.exists(): return jsonify(msg='Not Found'), 404 return send_file(file_path, conditional=True)app.register_blueprint(api_bp)if __name__ == '__main__': app.run(host='localhost', port=10000, debug=True) 客户端实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124import { Component, OnInit } from \"@angular/core\";import { HttpClient } from \"@angular/common/http\";import { UploadFile } from \"ng-zorro-antd/upload\";import { ArrayBuffer } from \"spark-md5\";import { zip } from \"rxjs\";import { map } from \"rxjs/operators\";import * as _ from \"lodash\";@Component({ selector: \"app-root\"})export class AppComponent implements OnInit { splitChunk = false; fileList: UploadFile[] = []; constructor(private http: HttpClient) {} ngOnInit() { // this.http.get(\"/api/ping\").subscribe(resp =&gt; console.log(resp)); } beforeUpload = (file: UploadFile): boolean =&gt; { this.fileList = this.fileList.concat(file); return false; }; chunkUpload() { const fileItem = this.fileList[0]; const suffix = fileItem.name .split(\".\") .pop() .toLowerCase(); // 按照100M切分 const fileChunks = this.createChunks(fileItem, 100 * 1024 * 1024); const spark = new ArrayBuffer(); // 定义这个方法的原因是是异步转为顺序执行 const loadChunk = (n: number) =&gt; { const reader = new FileReader(); reader.readAsArrayBuffer(fileChunks[n]); reader.onload = ev =&gt; { spark.append(ev.target.result as any); // 当序号小于长度时，继续加载后续块 if (n &lt; fileChunks.length - 1) { loadChunk(n + 1); } else { const hash = spark.end(); const name = `${hash}.${suffix}`; const formData = new FormData(); formData.append(\"name\", name); // 现获取一次进度信息 this.http .post(\"/api/upload/progress\", formData) .pipe(map((resp: any) =&gt; resp.progress)) .subscribe((progress: any) =&gt; { if (progress !== \"finished\") { const fileRes = fileChunks .map((chunk: Blob, index: number) =&gt; { if (_.isArray(progress) &amp;&amp; !_.includes(progress, index)) { // 仅仅上传未成功的部分 const formData = new FormData(); formData.append(\"name\", name); formData.append(\"chunk\", chunk, `${name}-${index}`); return this.http.post(\"/api/upload/chunk\", formData); } }) .filter(v =&gt; !!v); // 需要上传部分文件 if (fileRes) { zip(...fileRes).subscribe(() =&gt; { this.sendReqToCombine(name); }); } else { // 服务端已存在所有分片，但是未合并 this.sendReqToCombine(name); } } else { // 如果已经上传完成 console.log(\"ok\"); } }); } }; }; loadChunk(0); } singleUpload() { const fileItem = this.fileList[0]; const formData = new FormData(); formData.append(\"file\", fileItem as any); this.http.post(\"/api/upload/normal\", formData).subscribe(() =&gt; { console.log(\"ok\"); }); } handleUpload() { if (this.splitChunk) { this.chunkUpload(); } else { this.singleUpload(); } } // 发送请求合并文件 sendReqToCombine(name: string) { const formData = new FormData(); formData.append(\"name\", name); this.http.post(\"/api/upload/combine\", formData).subscribe(() =&gt; { console.log(\"ok\"); }); } // 切位文件为多个块 createChunks(file: UploadFile, size: number) { const chunks: Blob[] = []; let cursor = 0; do { chunks.push(file.slice(cursor, cursor + size)); cursor += size; } while (cursor &lt;= file.size); return chunks; }} html 模板(显示问题，单独放到了后面) 12345678910111213141516&lt;div&gt; &lt;nz-switch [(ngModel)]=\"splitChunk\"&gt;&lt;/nz-switch&gt; &lt;nz-upload [(nzFileList)]=\"fileList\" [nzBeforeUpload]=\"beforeUpload\"&gt; &lt;button nz-button [disabled]=\"this.fileList.length\"&gt; &lt;i nz-icon nzType=\"upload\"&gt;&lt;/i&gt;&lt;span&gt;Select&lt;/span&gt; &lt;/button&gt; &lt;/nz-upload&gt; &lt;button nz-button [nzType]=\"'primary'\" (click)=\"handleUpload()\" [disabled]=\"fileList.length == 0\" &gt; Upload &lt;/button&gt;&lt;/div&gt;","link":"/2020/03/31/%E5%88%86%E7%89%87%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/"},{"title":"函数柯里化","text":"","link":"/2020/04/12/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/"},{"title":"实现JSON.stringify","text":"测试代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import 'mocha';import { expect } from 'chai';import { stringify } from '../../src/json';describe('JSON stringify', () =&gt; { it('should parse string', () =&gt; { expect(stringify('string')).to.equal('string'); }); it('should parse number', () =&gt; { expect(stringify(1)).to.equal('1'); }); it('should parse null', () =&gt; { expect(stringify(null)).to.equal('null'); }); it('should parse undefined', () =&gt; { expect(stringify(undefined)).to.equal('undefined'); }); it('should parse empty array', () =&gt; { expect(stringify([])).to.equal('[]'); }); it('should parse flat array', () =&gt; { expect(stringify([1, 2, 3])).to.equal('[1, 2, 3]'); }); it('should parse nest array', () =&gt; { expect(stringify([1, 2, { a: [3, 4, 5] }])).to.equal( '[1, 2, {\"a\": [3, 4, 5]}]', ); }); it('should parse empty object', () =&gt; { expect(stringify({})).to.equal('{}'); }); it('should parse flat object', () =&gt; { expect(stringify({ a: 1 })).to.equal('{\"a\": 1}'); }); it('should parse nest object', () =&gt; { expect(stringify({ a: 1, b: 2, c: { d: 1 } })).to.equal( '{\"a\": 1, \"b\": 2, \"c\": {\"d\": 1}}', ); }); it('should resolve circular dependency', () =&gt; { const a: any = {}; const b: any = {}; b.a = a; a.b = b; expect(() =&gt; { stringify(a); }).to.throw('Circular Dependency'); }); it('should resolve same reference', () =&gt; { const a: any = {}; const o: any = { d: 1 }; a.b = o; a.c = o; expect(stringify(a)).to.equal('{\"b\": {\"d\": 1}, \"c\": {\"d\": 1}}'); });});","link":"/2020/04/30/%E5%AE%9E%E7%8E%B0JSON-stringify/"},{"title":"实现rxjs中的Observable","text":"内容来源于 Ben Lesh 的视频 Creating Observable From Scratch，可以观看视频以加深理解。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class SafeObserver { destination: any; isUnsubscribed = false; _unsubscribe: any = null; constructor(destination: any) { this.destination = destination; } next(value: any): void { const destination = this.destination; if (destination.next &amp;&amp; !this.isUnsubscribed) { destination.next(value); } } error(error: any): void { const destination = this.destination; if (!this.isUnsubscribed) { this.unsubscribe(); if (destination.error) { destination.error(error); } } } complete(): void { const destination = this.destination; if (!this.isUnsubscribed) { this.unsubscribe(); if (destination.complete) { destination.complete(); } } } unsubscribe(): void { this.isUnsubscribed = true; if (this._unsubscribe) { this._unsubscribe(); } }}class Observable { _subscribe: any; constructor(subscribe: any) { this._subscribe = subscribe; } subscribe(observer: any): any { const safeObserver = new SafeObserver(observer); safeObserver._unsubscribe = this._subscribe(safeObserver); return { unsubscribe(): void { safeObserver.unsubscribe(); }, }; }}","link":"/2020/04/06/%E5%AE%9E%E7%8E%B0rxjs%E4%B8%AD%E7%9A%84Observable/"},{"title":"创建自定义的rxjs操作符","text":"首先，操作符一般是在pipe中使用的，所以了解它的原理至关重要 12345class Observable { pipe(...operators): Observable&lt;any&gt; { return operators.reduce((source, next) =&gt; next(source), this); }} pipe会将所有的操作符归并（操作符嵌套调用，返回函数作为下一个操作符的参数）为一个函数 Angular 中的 HTTP 拦截器也是同样的原理 为了更好地说明，举个例子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546type callable = (...args: any) =&gt; any;const source = (): any =&gt; { console.log(\"call source\"); return \"ok\";};function A(callback: callable): callable { console.log(\"call A 1\"); return (): any =&gt; { console.log(\"call A 2\"); const result = callback(); console.log(\"call A 3\"); return result; };}function B(callback: callable): callable { console.log(\"call B 1\"); return (): any =&gt; { console.log(\"call B 2\"); const result = callback(); console.log(\"call B 3\"); return result; };}function C(callback: callable): callable { console.log(\"call C 1\"); return (): any =&gt; { console.log(\"call C 2\"); const result = callback(); console.log(\"call C 3\"); return result; };}const func = [A, B, C].reduce((source, next: callable) =&gt; next(source), source);// call A 1// call B 1// call C 1const result = func();// call C 2// call B 2// call A 2// call source// call A 3// call B 3// call C 3console.log(result);// ok 理解了pipe如何处理操作符，就可以很轻松的自定义操作符，只要最终返回为一个函数即可： 123456789101112131415161718192021222324252627282930313233343536373839404142import { interval, Observable } from \"rxjs\";import { map } from \"rxjs/operators\";function MyOperator&lt;T&gt;(callback: (v: T) =&gt; T = (v: T): T =&gt; v) { // 必须返回函数以嵌套调用 // 可以在已有操作符上拓展，例如 // function filterNil() { // return filter((value) =&gt; value !== undefined &amp;&amp; value !== null); // } return (source: Observable&lt;T&gt;): Observable&lt;T&gt; =&gt; { // 归并过程将source替换为新建Observable对象 // 可以在已有操作符上拓展，例如 // function filterNil() { // return function &lt;T&gt;(source: Observable&lt;T&gt;) { // return source.pipe( // filter((value) =&gt; value !== undefined &amp;&amp; value !== null), // ); // }; // } return new Observable(subscriber =&gt; { return source.subscribe({ next(value: T) { subscriber.next(callback(value)); }, error(error) { subscriber.error(error); }, complete() { subscriber.complete(); } }); }); };}interval(1000) .pipe( // MyOperator is same as map MyOperator((v: number) =&gt; v + 1), map((v: number) =&gt; v + 1) ) .subscribe((v: number) =&gt; console.log(v));","link":"/2020/04/02/%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84rxjs%E6%93%8D%E4%BD%9C%E7%AC%A6/"},{"title":"实现防抖和节流","text":"防抖：如果存在定时器，清除定时器，重新设置一个新的，直到定时器最后触发 节流：通过时间戳或定时器实现 时间戳：当前时间减去上一次触发时间，如果大于等于时间间隔才触发 定时器：检查定时器是否存在，存在则跳过，不存在则设置一个定时器，定时器触发后，将timer置为null，特别注意需要通过一个额外变量来更新回调函数的参数，否则参数不是最新的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889import { interval } from 'rxjs';/** * 实现防抖 * @param fn * @param delay */function debounce(fn: (...args: any[]) =&gt; any, delay: number): any { let timer: any = null; return function (...args: any[]) { const self = this; if (timer) { clearTimeout(timer); } timer = setTimeout(() =&gt; { fn.apply(self, args); }, delay); };}/** * 通过时间戳实现节流 * @param fn * @param delay */function throttleByDate(fn: (...args: any[]) =&gt; any, delay: number): any { let startTime = Date.now(); let first = true; return function (...args: any[]) { console.log(args); const self = this; if (first) { fn.apply(self, args); first = false; } if (Date.now() - startTime &gt;= delay) { fn.apply(this, args); startTime = Date.now(); } };}/** * 通过定时器实现节流 * @param fn * @param delay */function throttleByTimer(fn: (...args: any[]) =&gt; any, delay: number): any { let timer: any = null; let tmpArgs: any[]; let first = true; return function (...args: any[]) { console.log(args); // FIXME 触发值不是最新的：通过修改闭包变量来同步最新参数 tmpArgs = args; const self = this; if (first) { fn.apply(self, tmpArgs); first = false; } if (!timer) { timer = setTimeout(() =&gt; { fn.apply(self, tmpArgs); timer = null; }, delay); } };}window.onload = () =&gt; { // 测试防抖 const input = document.getElementById('input'); input?.addEventListener( 'input', debounce(function (ev) { const target = ev.target as any; console.log(target.value); console.log(this); }, 1000), ); // 测试节流 interval(1000).subscribe( throttleByDate((v) =&gt; { console.log(v); }, 5000), );};","link":"/2020/05/05/%E5%AE%9E%E7%8E%B0%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/"},{"title":"如何在Angular中导致内存泄漏","text":"参考原文链接 https://medium.com/angular-in-depth/how-to-create-a-memory-leak-in-angular-4c583ad78b8b 什么是内存管理？ 分配所需的内存 读写分配的内存 释放不用的内存 在 JavaScript 的世界中，通过 GC 完成内存的分配和释放，但是 GC 是如何工作的呢？ 垃圾收集器的工作原理基于引用计数实现：如果一块内存存在一个标签可以访问它，那么它的引用计数加一；丢失访问的标签时，引用计数减一；当没有任何标签可以访问它也就是引用计数为零时，GC 就会回收这块内存，清除数据。 WeakMap使用对象作为 key 不会增加对象的引用计数 在 JavaScript 中，从全局对象（window）开始遍历所有对象，每个对象初始都包含一个 mark=false 标志 遍历过程中，可访问的对象设置 mark=true 之后 GC 将所有 mark=false 的对象回收 GC 会定期执行此算法，管理可用内存。 如何在 Angular 中制造内存泄漏概括为一句话：在订阅了比组件生命周期长的服务暴露出来的可观察对象（Observable 或 Subject 等），但却没有在组件销毁时取消订阅的情况下，可能会出现内存泄漏。 如果可观察对象的声明周期与组件一致，不会出现内存泄漏。 反之则会内存泄漏 解决订阅可观察对象导致的内存泄漏使用组件销毁钩子ngOnDestroy和destroy$取消订阅 12345678910111213141516171819202122232425import { Component, OnDestroy } from \"@angular/core\";import { Subject } from \"rxjs\";import { takeUntil } from \"rxjs/operators\";import { DummyService } from \"./dummy.service\";@Component({ selector: \"app-hello\", template: \"...\"})export class HelloComponent implements OnDestroy { destroy$ = new Subject&lt;void&gt;(); value: number; constructor(private dummyService: DummyService) { // 当destroy$触发时取消订阅 this.dummyService.some$ .pipe(takeUntil(this.destroy$)) .subscribe((v: number) =&gt; { this.value = v; }); } ngOnDestroy(): void { this.destroy$.next(); this.destroy$.complete(); }}","link":"/2020/04/01/%E5%A6%82%E4%BD%95%E5%9C%A8Angular%E4%B8%AD%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"},{"title":"构建你自己的React","text":"原文链接：https://pomb.us/build-your-own-react/ 我们将从头开始，遵循真实的 React 源码架构，排除掉所有的优化和非必要的功能。一步一步地重新构建我们自己版本的 React。 这篇文章与你所阅读过其他相同主题的文章最大不同是基于 React 16.8 版本，因此我们可以使用钩子，并且删除所有与类相关的代码。 开始我们的教程之前，明确以下内容将是我们自己版本 React 的所有内容： createElement()：创建节点对象 render()：渲染节点对象到 DOM Concurrent Mode：实现 JS 任务和 GUI 任务平衡 Fibers：构建虚拟 DOM 对象 Render and Commit Phases：收集变更，提交整体 Reconciliation：处理变更收集 Function Component：实现函数式组件 Hooks：实现 useState 钩子 回顾 首先让我们回顾一些 React 相关的基础概念，如果你已经非常熟悉 React、JSX 和 DOM 元素的工作原理，你可以跳过此步骤。 123const element = &lt;h1 title=\"foo\"&gt;Hello&lt;/h1&gt;;const container = document.getElementById(\"root\");ReactDOM.render(element, container); 最简单的 React 应用仅仅只需三行代码：第一行定义一个 React 节点元素，第二行从 DOM 中获取一个节点作为容器，最后一行调用 render 函数渲染 React 节点元素到容器中。 现在让我们删除所有 React 特殊语法（JSX）的代码，用原生 JavaScript 代码代替。 第一行代码定义一个节点元素使用到了 JSX 语法，它不是合法的 JavaScript 代码，让我们用原生语法替换它。 JSX 语法是通过 Babel 等构建工具在编译时转换为 JavaScript 的，它的转换过程十分简单：将标签替换为 createElement 的函数，依次传递参数标签名、标签属性和所有子节点，子节点转换过程递归进行。 这也是为什么用到 jsx 语法需要引入import React from 'react'的原因。 1234const element = &lt;h1 title=\"foo\"&gt;Hello&lt;/h1&gt;;// 编译后const element = React.createElement(\"h1\", { title: \"foo\" }, \"Hello\"); React.createElement 使用传递的参数创建一个对象，处理一些验证之外，没有其他额外功能。因此我们也可以将函数调用替换为其输出结果。 12345678910const element = React.createElement(\"h1\", { title: \"foo\" }, \"Hello\");// 替换后const element = { type: \"h1\", props: { title: \"foo\", children: \"Hello\", },}; 所以一个 React 节点元素可以被简单描述为：一个具有两个属性 type 和 props 的对象（当然，它有更多的属性，但是我们只关心这两个）。 createElement()：创建节点对象 现在我们来自己实现创建节点对象的过程，就从替换 React.createElement 开始。 从 JSX 到 JS 的转换过程中，编译之后的代码调用的 createElement 函数，上一节中说明了一个节点会被描述为具有两个属性 type 和 props 的对象。所以函数唯一需要做的就是通过参数构造一个对象： 123456789function createElement(type, props, ...children) { return { type, props: { ...props, children, }, };} children的类型可能会进一步嵌套，为了归一化处理，新增一个函数构造直接用于显示文本的节点 123456789101112131415161718192021function createElement(type, props, ...children) { return { type, props: { ...props, // 思考：为什么不需要处理object类型的child？ children: children.map((child) =&gt; typeof child === \"object\" ? child : createTextElement(child) ), }, };}function createTextElement(text) { return { type: \"TEXT_ELEMENT\", props: { nodeValue: text, children: [], }, };} 想要使用我们自己的函数处理 JSX，需要配置 tsconfig.json，如果有必要关闭一些检查。 12345{ \"compilerOptions\": { \"jsxFactory\": \"Didact.createElement\" }} render()：渲染节点对象到 DOM 通过深度递归遍历 js 对象可以依次构造 dom 节点，最后挂载到根容器 1234567891011121314151617181920function render(element, container) { const dom = element.type === \"TEXT_ELEMENT\" ? document.createTextNode(\"\") : document.createElement(element.type); // 不为children的属性都复制到dom节点上 const isProperty = (key) =&gt; key !== \"children\"; Object.keys(element.props) .filter(isProperty) .forEach((name) =&gt; { dom[name] = element.props[name]; }); // 递归构建dom树 element.props.children.forEach((child) =&gt; render(child, dom)); // 挂载到父节点 container.appendChild(dom);} Concurrent Mode：实现 JS 任务和 GUI 任务平衡 上一节的渲染方式有一个很大的问题：递归没法停止，一旦开始无法结束。如果元素树很大，它可能长时间阻塞主线程。如果浏览器需要做一些高优先级的事情，比如处理用户输入或者保持动画的平滑，它将不得不等待渲染完成。 所以我们将把工作分解成小单元，在我们完成每个单元后，如果有任何其他需要完成的事情，我们将让浏览器中断渲染。 我们使用 requestIdleCallback 来进行循环。你可以将 requestIdleCallback 看作是 setTimeout，但是我们不告诉它何时运行，浏览器将在主线程空闲时运行回调。 React 不使用 requestIdleCallback，它使用自己构建的 scheduler 库，但是概念上是相同的。 12345678910111213141516171819let nextUnitOfWork = null;function workLoop(deadline) { let shouldYield = false; while (nextUnitOfWork &amp;&amp; !shouldYield) { // 执行单元任务 nextUnitOfWork = performUnitOfWork(nextUnitOfWork); // 通过剩余时间判断是否需要立刻交还执行权 shouldYield = deadline.timeRemaining() &lt; 1; } // 执行权交还给浏览器 requestIdleCallback(workLoop);}requestIdleCallback(workLoop);function performUnitOfWork(nextUnitOfWork) { // TODO 处理单元任务} Fibers：构建虚拟 DOM 对象 在处理单元任务之前，我们需要明确如何切分任务。未优化之前一口气处理一整棵 dom 树，现在可以很自然地根据数据结构切分，我们将 dom 树每个节点的处理视为一个单元任务。对于每个节点的处理 React 构造了一个特殊的对象：Fiber，其实和我们之前了解的虚拟 dom 对象没什么不同。 下面我们开始讲解如何使用 Fiber 对象描述 dom 结构： 1234567&lt;div&gt; &lt;h1&gt; &lt;p /&gt; &lt;a /&gt; &lt;/h1&gt; &lt;h2 /&gt;&lt;/div&gt; 使用这样数据结构的目标之一是使查找下一个工作单元变得容易。 这就是为什么每个 Fiber 对象都链接到其第一个子节点，下一个兄弟节点和父节点。 在render函数中，我们会创建根 Fiber 然后设置其为第一个nextUnitOfWork，剩余任务将全部交给performUnitOfWork处理和 requestIdleCallback调度，对于每一个节点 Fiber，会做一下三件事情： 1. 添加节点元素到dom 2. 遍历节点的children属性创建Fiber对象 3. 设置一个Fiber对象作为下一个单元任务当我们完成一个 Fiber 对象的工作后，如果它有 child，就把 child 构建为 Fiber 对象然后设置为下一个单元任务。 如果没有 child，就会使用此节点的 sibling 作为下一个目标 如果既没有 child 也没有 sibling，那么会回到父节点，如果父节点也没有 child 和 sibling，就会回到爷爷节点，依次类推。 回到代码，移除render函数的代码，将创建 dom 的逻辑拎出来 123456789101112131415161718function createDom(fiber) { const dom = fiber.type == \"TEXT_ELEMENT\" ? document.createTextNode(\"\") : document.createElement(fiber.type)​ const isProperty = key =&gt; key !== \"children\" Object.keys(fiber.props) .filter(isProperty) .forEach(name =&gt; { dom[name] = fiber.props[name] })​ return dom}​function render(element, container) {} 接着构造根 Fiber 对象作为第一个单元任务，然后准备处理任务 1234567891011121314function render(element, container) { nextUnitOfWork = { dom: container, props: { children: [element], }, };}function performUnitOfWork(fiber) { // TODO 添加节点元素到dom // TODO 遍历节点的children属性创建Fiber对象 // TODO 设置一个Fiber对象作为下一个单元任务} 最后依次实现 TODO 即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950function performUnitOfWork(fiber) { // 添加节点元素到dom // 如果没有dom属性，根据fiber新构建 if (!fiber.dom) { fiber.dom = createDom(fiber); } // 如果存在父节点，将dom挂载 if (fiber.parent) { fiber.parent.dom.appendChild(fiber.dom); } // 遍历节点的children属性创建Fiber对象 const elements = fiber.props.children; let index = 0; let prevSibling = null; while (index &lt; elements.length) { const element = elements[index]; const newFiber = { type: element.type, props: element.props, parent: fiber, dom: null, }; // 父fiber的child指向第一个子fiber if (index === 0) { fiber.child = newFiber; } else { // 如果存在兄弟节点，通过sibling关联 prevSibling.sibling = newFiber; } // 暂存上一个兄弟节点 prevSibling = newFiber; index++; } // 设置一个Fiber对象作为下一个单元任务 // 优先使用父fiber的child if (fiber.child) { return fiber.child; } let nextFiber = fiber; while (nextFiber) { // 其次使用父fiber的sibling if (nextFiber.sibling) { return nextFiber.sibling; } // 如果没有回退到父节点的parent nextFiber = nextFiber.parent; }} Render and Commit Phases：收集变更，提交整体 运行一下看起来不错，但是仍然存在一个很大的问题：我们通过遍历 fiber 树的方式依次向 dom 上添加节点元素，运行过程依赖浏览器 API requestIdleCallback的调度，它不是同步的，一些优先级更高的任务可能会提前执行，从而阻塞或延迟我们的 dom 渲染，有可能会出现渲染不完整的 dom 情况。解决思路是把操作 dom 的逻辑和调度分离，从而同步完成 dom 的整体渲染。 首先移除操作 dom 的代码 123456function performUnitOfWork(fiber) { // 移除dom操作 // if (fiber.parent) { // fiber.parent.dom.appendChild(fiber.dom); // }} 通过一个全局变量追踪正在处理的根 fiber 1234567891011function render(element, container) { wipRoot = { dom: container, props: { children: [element], }, } nextUnitOfWork = wipRoot}​let wipRoot = null 在调度模块中，如果没有下一个单元任务且进行中的根节点存在，就提交整个 dom 树 123456789101112131415161718192021222324252627282930313233343536function commitRoot() { // 从根节点的child开始 commitWork(wipRoot.child); // 完成后置空进行中根节点 wipRoot = null;}function commitWork(fiber) { // child和sibling可能为undefined if (!fiber) { return; } const domParent = fiber.parent.dom; domParent.appendChild(fiber.dom); commitWork(fiber.child); commitWork(fiber.sibling);}function workLoop(deadline) { let shouldYield = false; while (nextUnitOfWork &amp;&amp; !shouldYield) { // 执行单元任务 nextUnitOfWork = performUnitOfWork(nextUnitOfWork); // 通过剩余时间判断是否需要立刻交还执行权 shouldYield = deadline.timeRemaining() &lt; 1; } // 没有下一个单元任务且进行中的根节点存在 if (!nextUnitOfWork &amp;&amp; wipRoot) { commitRoot(); } // 执行权交还给浏览器 requestIdleCallback(workLoop);} Reconciliation：处理变更收集 目前为止，我们仅仅是添加节点，但是如何更新或删除节点呢？ 将 render 函数接受的节点和最后一次构建的 fiber 树进行对比，以此来确定节点的添加、更新和删除。所以我们需要在每次提交渲染后保存刚构建的 fiber 树，并且为每个 fiber 对象添加一个额外属性用于链接旧的 fiber 对象（链接的对象总是 fiber 树同一个位置），通过这种方式复用对象。 额外创建一个 currentRoot 来保存刚渲染的 fiber 树根节点，并且把它和正在构建的 fiber 树根节点通过属性alternate链接 123456789101112131415161718function commitRoot() { commitWork(wipRoot.child); currentRoot = wipRoot; wipRoot = null;}function render(element, container) { wipRoot = { dom: container, props: { children: [element], }, alternate: currentRoot, } nextUnitOfWork = wipRoot}​let currentRoot = null 然后让我们来重构performUnitOfWork的代码，新建一个reconcileChildren函数来调和变更，主要完成通过旧 fiber 构建新 fiber，提供标记以便提交阶段完成对应的 dom 操作。 1234567891011121314151617181920212223function performUnitOfWork(fiber) { if (!fiber.dom) { fiber.dom = createDom(fiber) }​ const elements = fiber.props.children reconcileChildren(fiber, elements)​ if (fiber.child) { return fiber.child } let nextFiber = fiber while (nextFiber) { if (nextFiber.sibling) { return nextFiber.sibling } nextFiber = nextFiber.parent }}function reconcileChildren(wipFiber, elements) { // TODO 调和变更} 节点的变更先简单地分为三种情况： 1. 如果type相同，保留以前的dom，仅仅更新dom属性 2. 如果type不同，存在element，新建dom 3. 如果type不同，存在oldFiber，删除oldFiber的dom123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263function reconcileChildren(wipFiber, elements) { let index = 0; let oldFiber = wipFiber.alternate &amp;&amp; wipFiber.alternate.child; let prevSibling = null; // TODO 思考：为什么不能用 oldFiber !== null // oldFiber一直为undefined，会造成死循环 while (index &lt; elements.length || oldFiber != null) { const element = elements[index]; let newFiber = null; const sameType = oldFiber &amp;&amp; element &amp;&amp; element.type == oldFiber.type; // 更新 if (sameType) { newFiber = { type: oldFiber.type, props: element.props, dom: oldFiber.dom, parent: wipFiber, alternate: oldFiber, effectTag: \"UPDATE\", }; } // 重新创建 if (element &amp;&amp; !sameType) { newFiber = { type: element.type, props: element.props, dom: null, parent: wipFiber, alternate: null, effectTag: \"PLACEMENT\", }; } // 删除 if (oldFiber &amp;&amp; !sameType) { oldFiber.effectTag = \"DELETION\"; deletions.push(oldFiber); } // 同时遍历旧fiber树 if (oldFiber) { oldFiber = oldFiber.sibling; } // 父fiber的child指向第一个子fiber if (index === 0) { wipFiber.child = newFiber; } /* 当oldFiber != null时，需要判断element存在才设置sibling */ else if ( element ) { // 如果存在兄弟节点，通过sibling关联 prevSibling.sibling = newFiber; } // 暂存上一个兄弟节点 prevSibling = newFiber; index++; }} 我们在newFiber上添加了effectTag来标记对应的 dom 操作，接下来会在 commit 阶段使用到。PLACEMENT对应新建 dom 节点；UPDATE对应更新节点属性；删除节点除了标记为DELETION，还需要特殊处理。因为无法通过newFiber节点访问到需要删除的节点，所以需要引入一个全局数组，暂存一下需要删除的节点，每次 render 之前置空： 12345678910111213function render(element, container) { wipRoot = { dom: container, props: { children: [element], }, alternate: currentRoot, } deletions = [] nextUnitOfWork = wipRoot}​let deletions = null 修改 commit 节点代码，根据标记完成对应的 dom 操作 1234567891011121314151617181920212223242526272829303132333435function commitRoot() { // 优先进行删除操作 deletions.forEach(commitWork); // 从根节点的child开始 commitWork(wipRoot.child); // 保存刚构建的fiber树 currentRoot = wipRoot; // 完成后置空进行中根节点 wipRoot = null;}function commitWork(fiber) { // child和sibling可能为undefined if (!fiber) { return; } const domParent = fiber.parent.dom; if (fiber.effectTag === \"PLACEMENT\" &amp;&amp; fiber.dom != null) { domParent.appendChild(fiber.dom); } if (fiber.effectTag === \"UPDATE\" &amp;&amp; fiber.dom != null) { updateDom(fiber.dom, fiber.alternate.props, fiber.props); } if (fiber.effectTag === \"DELETION\") { domParent.removeChild(fiber.dom); return; } commitWork(fiber.child); commitWork(fiber.sibling);} 抽离一个单独的方法updateDom更新 dom 属性 12345678910111213141516171819202122232425262728293031323334353637383940const isEvent = (key) =&gt; key.startsWith(\"on\");const isProperty = (key) =&gt; key !== \"children\" &amp;&amp; !isEvent(key);const isNew = (prev, next) =&gt; (key) =&gt; prev[key] !== next[key];const isGone = (next) =&gt; (key) =&gt; !(key in next);function updateDom(dom, prevProps, nextProps) { // 移除旧事件 Object.keys(prevProps) .filter(isEvent) .filter((key) =&gt; !(key in nextProps) || isNew(prevProps, nextProps)(key)) .forEach((name) =&gt; { const eventType = name.toLowerCase().substring(2); dom.removeEventListener(eventType, prevProps[name]); }); // 删除旧属性 Object.keys(prevProps) .filter(isProperty) .filter(isGone(nextProps)) .forEach((name) =&gt; { dom[name] = \"\"; }); // 设置新属性 Object.keys(nextProps) .filter(isProperty) .filter(isNew(prevProps, nextProps)) .forEach((name) =&gt; { dom[name] = nextProps[name]; }); // 添加新事件 Object.keys(nextProps) .filter(isEvent) .filter(isNew(prevProps, nextProps)) .forEach((name) =&gt; { const eventType = name.toLowerCase().substring(2); dom.addEventListener(eventType, nextProps[name]); });} 同样可以替换createDom中的 dom 操作，将prevProps设为空对象即可 12345678910function createDom(fiber) { const dom = fiber.type == \"TEXT_ELEMENT\" ? document.createTextNode(\"\") : document.createElement(fiber.type); updateDom(dom, {}, fiber.props); return dom;} Function Component：实现函数式组件 之前的章节全是围绕节点对象构建 Fiber 来渲染视图的，接下来就要为我们自己版本的 React 添加函数组件的支持。 12345678910const App = ({ name }) =&gt; { return &lt;div&gt;Hi {name}&lt;/div&gt;;};Didact.render(&lt;App name=\"defpis\" /&gt;, container);// 编译后const App = ({ name }) =&gt; { return Didact.createElement(\"div\", null, \"Hi \", name);};const element = Didact.createElement(App, { name: \"defpis\" }); 函数组件和普通节点对象有两方面的不同 1. 函数组件的fiber没有dom属性 2. 函数组件的视图需要调用函数得到因此在performUnitOfWork中分情况讨论 123456789101112131415161718192021222324252627function performUnitOfWork(fiber) { const isFunctionComponent = fiber.type instanceof Function; if (isFunctionComponent) { updateFunctionComponent(fiber); } else { updateHostComponent(fiber); } // ...}function updateFunctionComponent(fiber) { // TODO 更新函数组件}function updateHostComponent(fiber) { // 添加节点元素到dom // 如果没有dom属性，根据fiber新构建 if (!fiber.dom) { fiber.dom = createDom(fiber); } // 遍历节点的children属性创建Fiber对象 const elements = fiber.props.children; // 调和fiber对象，设置状态：添加、更新和删除 reconcileChildren(fiber, elements);} 继续完善函数组件的更新逻辑，调用函数获取节点对象组成 children 即可 1234function updateFunctionComponent(fiber) { const children = [fiber.type(fiber.props)]; reconcileChildren(fiber, children);} 但是reconcileChildren构建的 fiber 没有 dom 属性，所以 commit 阶段需要有所调整 1234567891011121314151617181920212223242526272829303132333435363738function commitWork(fiber) { // child和sibling可能为undefined if (!fiber) { return; } // 函数组件本身没有dom属性，需要向上寻找 let domParentFiber = fiber.parent; while (!domParentFiber.dom) { domParentFiber = domParentFiber.parent; } const domParent = domParentFiber.dom; if (fiber.effectTag === \"PLACEMENT\" &amp;&amp; fiber.dom != null) { domParent.appendChild(fiber.dom); } if (fiber.effectTag === \"UPDATE\" &amp;&amp; fiber.dom != null) { updateDom(fiber.dom, fiber.alternate.props, fiber.props); } if (fiber.effectTag === \"DELETION\") { commitDeletion(fiber, domParent); return; } commitWork(fiber.child); commitWork(fiber.sibling);}function commitDeletion(fiber, domParent) { // 找不到dom，继续向下寻找 if (fiber.dom) { domParent.removeChild(fiber.dom); } else { commitDeletion(fiber.child, domParent); }} Hooks：实现 useState 钩子 函数组件相较于类组件内部缺少存储状态的容器（class 的 this.state），因此需要引入 hook 实现视图和状态的关联。 还是从一个经典的例子计数器开始引出useState钩子 1234567function Counter() { const [state, setState] = Didact.useState(1); return &lt;button onClick={() =&gt; setState((c) =&gt; c + 1)}&gt;Count: {state}&lt;/button&gt;;}const element = &lt;Counter /&gt;;const container = document.getElementById(\"root\");Didact.render(element, container); 引入全局变量来确定正在处理的 fiber 对象以及正在处理的 hook，每次更新函数组件前稍作处理 12345678910let wipFiber = null;let hookIndex = null;function updateFunctionComponent(fiber) { wipFiber = fiber; wipFiber.hooks = []; hookIndex = 0; const children = [fiber.type(fiber.props)]; reconcileChildren(fiber, children);} 在每次useState调用时通过旧的 fiber 对象很容易获取到之前的 hook 对象，把它的状态传递给新 fiber 的 hooks 数组，因此可以做到多次函数调用持久化状态。 1234567891011121314function useState(initial) { const oldHook = wipFiber.alternate &amp;&amp; wipFiber.alternate.hooks &amp;&amp; wipFiber.alternate.hooks[hookIndex]; const hook = { state: oldHook ? oldHook.state : initial, }​ wipFiber.hooks.push(hook) hookIndex++ return [hook.state]} setState方法十分简单，在 hook 对象上维护一个队列，把回调函数都存放在里面，在下一次使用useState之前执行即可。为了保证setState会在之后生效，我们还需要将当前根 fiber 设置为下一次的单元任务。 12345678910111213141516171819202122232425262728293031323334function useState(initial) { const oldHook = wipFiber.alternate &amp;&amp; wipFiber.alternate.hooks &amp;&amp; wipFiber.alternate.hooks[hookIndex]; const hook = { state: oldHook ? oldHook.state : initial, queue: [], }; // 执行所有setState的回调函数 const actions = oldHook ? oldHook.queue : []; actions.forEach((action) =&gt; { hook.state = action(hook.state); }); const setState = (action) =&gt; { // 推入队列 hook.queue.push(action); // 将下一次任务设为当前根fiber wipRoot = { dom: currentRoot.dom, props: currentRoot.props, alternate: currentRoot, }; deletions = []; nextUnitOfWork = wipRoot; }; wipFiber.hooks.push(hook); hookIndex++; return [hook.state, setState];} 运行代码，点击页面刷新，计数增加。","link":"/2020/08/09/%E6%9E%84%E5%BB%BA%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%9A%84React/"},{"title":"显示多个请求的进度","text":"根据Promise.all()的原理扩展一下显示多个请求的进度信息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import { Observable } from \"rxjs\";import { delay } from \"rxjs/operators\";function delayValue(value: any, delayTime: number): Observable&lt;any&gt; { return new Observable((subscriber) =&gt; { subscriber.next(value); subscriber.complete(); }).pipe(delay(delayTime));}function showProgress( observables: Observable&lt;any&gt;[] = [], progressCallback: (progress: number) =&gt; void): Observable&lt;any[]&gt; { let count = 0; const result: any = []; return new Observable((subscriber) =&gt; { if (observables.length) { observables.forEach((item, index) =&gt; { count++; item.subscribe((value) =&gt; { count--; result[index] = value; const progress = result.filter((v: any) =&gt; v).length / observables.length; progressCallback(progress); if (!count) { subscriber.next(result); subscriber.complete(); } }); }); } else { progressCallback(1); subscriber.next(result); subscriber.complete(); } });}showProgress( [ delayValue(1, 1000), delayValue(2, 500), delayValue(3, 2000), delayValue(4, 1500), ], // 显示进度信息 (progress) =&gt; { console.log(\"Progress: \" + progress); }).subscribe((value) =&gt; console.log(value));// Progress: 0.25// Progress: 0.5// Progress: 0.75// Progress: 1// [ 1, 2, 3, 4 ]","link":"/2020/04/02/%E6%98%BE%E7%A4%BA%E5%A4%9A%E4%B8%AA%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BF%9B%E5%BA%A6/"},{"title":"浏览修改服务器文件的最佳方式","text":"前一段时间去看angularjs的源码很久没有更新博客了，直到昨天解决一个测试环境部署问题时，我发现了一个提高效率一百倍的技巧，今天就和大家分享一下 先登录远程服务器，将远程服务器的10099端口映射到本地端口 12➜ ssh -t xxxx@xxxx -fNL 10099:127.0.0.1:10099 -gxxxx@xxxx's password: 然后本地ssh登录 1234➜ ssh -p 10099 root@127.0.0.1root@127.0.0.1's password:Last login: Sat Feb 29 22:31:25 2020 from localhost[root@cj-test-node1 ~]# 使用ssh命令两次十分麻烦，而且每多开一个终端还要重复ssh登录，更重要的是浏览和修改服务器文件对于我们这些前端开发并不是熟悉的事情。由于vscode是我们默认的开发工具，我就想在上面寻找一款插件可以简化ssh的连接，最好找到了这款Remote - SSH 如果之前熟悉wsl的同学一定不陌生，vscode连接subsystem开发会装一堆remote的插件，Remote - SSH就是其中之一，它提供一下功能： 在您部署到本地操作系统的同一操作系统上进行开发，或使用比本地计算机更大，更快或更专业的硬件。 在不同的远程开发环境之间快速交换，并安全地进行更新，而不必担心会影响本地计算机。 从多台机器或位置访问现有的开发环境。 调试在其他位置（例如客户站点或云中）运行的应用程序。 对比于之前的例子，使用插件来建立ssh连接步骤十分简单： 同样映射端口到本地，和之前相同 12➜ ssh -t xxxx@xxxx -fNL 10099:127.0.0.1:10099 -gxxxx@xxxx's password: 安装插件后侧边栏会多一个图标，点击它 添加好之后点击连接 会提示输入密码 登录成功之后，需要切换到工作目录 之后我们就可以像浏览本地工程一下浏览服务器文件，并且控制台自动定位到当前目录 如果还需要调试暴露端口的远程服务，可以通过插件快速转发，极其方便","link":"/2020/03/01/%E6%B5%8F%E8%A7%88%E4%BF%AE%E6%94%B9%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%87%E4%BB%B6%E7%9A%84%E6%9C%80%E4%BD%B3%E6%96%B9%E5%BC%8F/"},{"title":"浮点数表示与计算误差","text":"为什么在 JavaScript 中计算浮点数可能存在误差？ 1console.log(0.1 + 0.2); // 0.30000000000000004 浮点数在计算机中的表示计算机使用二进制表示、存储和处理数据。为什么采用二进制，而不是人们更熟悉的十进制：因为使用物理电路模拟二进制数据状态更加容易，电路闭合为 1，电路断开为 0，通过电路闭合断开的物理过程来模拟数据的计算过程。 JavaScript 中的所有数字类型的表示都遵循一个叫 IEEE 754 的国际标准，使用双精度 64bit（没有采用单精度 32bit）组成 单精度 32bit 双精度 64bit 计算公式 符号位 S：第 1 位是正负数符号位（sign），0 代表正数，1 代表负数 指数位 E：中间的 11 位存储指数（exponent），用来表示次方数 尾数位 M：最后的 52 位是尾数（mantissa），超出的部分自动进一舍零 IEEE 754 对有效数字 M 和指数 E，还有一些特别规定。 前面说过，1≤M&lt;2，也就是说，M 可以写成 1.xxxxxx 的形式，其中 xxxxxx 表示小数部分。IEEE 754 规定，在计算机内部保存 M 时，默认这个数的第一位总是 1，因此可以被舍去，只保存后面的 xxxxxx 部分。比如保存 1.01 的时候，只保存 01，等到读取的时候，再把第一位的 1 加上去。这样做的目的，是节省 1 位有效数字。以 64 位浮点数为例，留给 M 只有 52 位，将第一位的 1 舍去以后，等于可以保存 53 位有效数字。 至于指数 E，情况就比较复杂。 首先，E 为一个无符号整数（unsigned int）。这意味着，如果 E 为 8 位，它的取值范围为 0~255；如果 E 为 11 位，它的取值范围为 0~2047。但是，我们知道，科学计数法中的 E 是可以出现负数的，所以 IEEE 754 规定，E 的真实值必须再减去一个中间数，对于 8 位的 E，这个中间数是 127；对于 11 位的 E，这个中间数是 1023。 所以 JavaScript 中数字表示的最终公式变成： 比如，2^10 的 E 是 10，所以保存成 32 位浮点数时，必须保存成 10+127=137，即 10001001。 然后，指数 E 还可以再分成三种情况： E 不全为 0 或不全为 1。这时，浮点数就采用上面的规则表示，即指数 E 的计算值减去 127（或 1023），得到真实值，再将有效数字 M 前加上第一位的 1。 E 全为 0。这时，浮点数的指数 E 等于 1-127（或者 1-1023），有效数字 M 不再加上第一位的 1，而是还原为 0.xxxxxx 的小数。这样做是为了表示 ±0，以及接近于 0 的很小的数字。 E 全为 1。这时，如果有效数字 M 全为 0，表示 ± 无穷大（正负取决于符号位 s）；如果有效数字 M 不全为 0，表示这个数不是一个数（NaN）。 回到 0.1+0.2 !== 0.3，把各个数字的单独表示 访问 http://www.binaryconvert.com/result_double.html 在线转换 数字 符号位 指数位 有效数位 是否循环 0.1 0 01111111011 1001100110011001100110011001100110011001100110011010 1100 0.2 0 01111111100 1001100110011001100110011001100110011001100110011010 1100 所以 0.1 和 0.2 表示成 IEEE 754 后有效数位都以 1001 无限循环，加起来结果 1234 0.0001100110011001100110011001100110011001100110011001101 0.0011001100110011001100110011001100110011001100110011010+ --------------------------------------------------------- 0.0100110011001100110011001100110011001100110011001100111 =&gt; 0.30000000000000004 为什么 x=0.1 能得到 0.1？隐式精度转换因为 mantissa 固定长度是 52 位，再加上省略的一位，最多可以表示的数是 2^53=9007199254740992，对应科学计数尾数是 9.007199254740992，这也是 JS 最多能表示的精度。它的长度是 16，所以可以使用 toPrecision(16) 来做精度运算，超过的精度会自动做凑整处理。于是就有： 12345// 返回 0.1000000000000000，去掉末尾的零后正好为 0.1(0.100000000000000005551).toPrecision(16); // 0.1// 但你看到的 `0.1` 实际上并不是 `0.1`。不信你可用更高的精度试试：(0.1).toPrecision(21); // 0.100000000000000005551; 最大可表示数字12Math.pow(2, 1023); // 8.98846567431158e+307Math.pow(2, 1024); // Infinity 可以使用第三方库解决大数计算问题 https://github.com/MikeMcl/bignumber.js/ 十进制转换二进制的方法以 0.1 举例 计算 取整 取余 0.1 * 2 = 0.2 0 0.2 0.2 * 2 = 0.4 0 0.4 0.4 * 2 = 0.8 0 0.8 0.8 * 2 = 1.6 1 0.6 0.6 * 2 = 1.2 1 0.2 0.2 * 2 = 0.4 0 0.4 0.4 * 2 = 0.8 0 0.8 … … … 0.1 =&gt; 0.00011001100... 易混淆 API API 功能 toPrecision 是处理精度，精度是从左至右第一个不为 0 的数开始数起 toFixed 是小数点后指定位数取整，从小数点开始数起 两者都能对多余数字做凑整处理，也有些人用 toFixed 来做四舍五入，但一定要知道它是有 Bug 的。 例如：1.005.toFixed(2) 返回的是 1.00 而不是 1.01。 原因：1.005 实际对应的数字是 1.00499999999999989，在四舍五入时全部被舍去！ 项目地址：https://github.com/defpis/calculate-float-number-in-js","link":"/2020/04/06/%E6%B5%AE%E7%82%B9%E6%95%B0%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%AE%A1%E7%AE%97%E8%AF%AF%E5%B7%AE/"},{"title":"构建你自己的ColorPicker","text":"好久没有更新博客了，真的印证了那句话：“字节一年，人间三年”，从入职到现在一直忙于项目上的事情。 最近在项目中使用到了颜色选择器，公司的组件库无法满足需要，所以我去 Github 找了相关实现，最后通过 react-color 凑合完成了任务。但是完成任务的我一直很好奇它是如何实现的，一不做二不休，干脆自己搞一个，万一 react-color 也没法满足项目需要的时候，我还可以手撸顶上去。 作为一个前端程序猿，还是比较熟悉颜色编码的，RGB 和 HEX 都能熟练使用，但是对于更多编码 HSL、HSB/HSV、CMYK 和 YUV 等就知之甚少了，并不清楚为啥同一个东西要整出这么多表现形式，为此我查阅了相关资料，收获颇丰。 RGB 和 HEX 本质上是一样的，都是通过 10 进制 0-255 或 16 进制 00-ff 来表示 R-Red、G-Green 和 B-Blue 三种光的权重，通过混合三种光来获的各种颜色。这种表示方法对于机器很好理解，但是对于人类就不那么直观了，一眼瞧过去，很难知道这是啥颜色，鲜艳不鲜艳，明亮还是灰暗，所以人们就基于这种痛点重新对颜色进行了编码，主要分为了 HSL、HSB/HSV 两种编码方式。（CMYK 和 YUV 暂时没有了解，如果有兴趣可以一起讨论） 查看色彩空间中的 HSL、HSV、HSB 有什么区别 首先，HSB 和 HSV 是同一个东西，只是名称不同。 HSB 和 HSL 在字面意思上是一样的： H 指的是色相（Hue），就是颜色名称，例如“红色”、“蓝色”； S 指的是饱和度（Saturation），即颜色的纯度； L（Lightness） 和 B（Brightness）是明度，颜色的明亮程度 在表现和原理上，HSB 和 HSL 中的 H（色相）完全一致，但是二者的 S（饱和度）和不一样，L 和 B（明度）也不一样。 HSB 中的 S 控制纯色中混入白色的量，值越大，白色越少，颜色越纯； HSB 中的 B 控制纯色中混入黑色的量，值越大，黑色越少，明度越高； HSL 中的 S 和黑白没有关系，饱和度不控制颜色中混入黑白的多寡； HSL 中的 L 控制纯色中的混入的黑白两种颜色，作用等同于 HSB 中的 S 和 B 之和； 想必看到这里的你一定还是很迷糊为啥可以通过参杂黑白控制饱和度或明度，而饱和度具体定义有代表什么？别着急，可以看一下这篇文章公式剖析色彩三要素：色相、饱和度、明度，里面比较详细阐述了色彩三要素具体的含义，并且非常好的为每一种要素的提供了数学概念，通过数学概念能深入理解颜色的表示方法。 至此理论知识补充的差不多了，可以开始实践操作了。我也去网上找了已有的实现，按照自己的理解重新撸了一个版本。 实际效果如图 UI 主要分为三部分 饱和度面板 色相拖动条 透明度拖动条 目录结构如下 1234567891011121314ColorPicker├── ColorPicker.scss├── ColorPicker.tsx├── components│ ├── Alpha // 透明度│ │ ├── Alpha.scss│ │ └── Alpha.tsx│ ├── Hue // 色相│ │ ├── Hue.scss│ │ └── Hue.tsx│ └── Saturation // 饱和度│ ├── Saturation.scss│ └── Saturation.tsx└── hooks // 通用逻辑 首先来构建饱和度面板 12345678910111213141516171819&lt;div style={{ width: `${width}px`, height: `${height}px` }} className=\"color-picker-wrapper color-picker-saturation\"&gt; &lt;div ref={ref} style={{ background: `hsl(${hsva.h}, 100%, 50%)` }} className=\"saturation\" &gt; &lt;div className=\"saturation-thumb\" style={{ left: `${pos.offsetX}px`, top: `${pos.offsetY}px`, borderColor: pos.offsetY &lt; height / 2 ? \"black\" : \"white\", }} /&gt; &lt;/div&gt;&lt;/div&gt; 通过伪元素来叠加两层透明渐变遮罩层，一层从全白到透明，另一层从全黑到透明，分表向 X 和 Y 轴渐变，样式如下 123456789101112131415161718192021222324252627282930313233.color-picker-saturation { @mixin saturation-pseudo-element { @include full(); content: \"\"; position: absolute; } .saturation { @include full(); background: transparent; cursor: crosshair; &amp;::before { @include saturation-pseudo-element(); background: linear-gradient(to right, white, transparent); } &amp;::after { @include saturation-pseudo-element(); background: linear-gradient(to top, black, transparent); } .saturation-thumb { position: absolute; transform: translate(-10px, -8px); z-index: 1; width: 15px; height: 15px; border-radius: 50%; border: 1px solid; background-color: transparent; } }} 预留了一个 div 作为滑块，通过设置为绝对定位，然后根据传入的坐标来渲染。 至于拖动的逻辑，封装到成了 useMouseDrag，方便之后 Slider 组件复用 可以像 useRef 一样使用获得一个 ref 引用 1const [ref, pos, setPos] = useMouseDrag&lt;HTMLDivElement&gt;(null); 通过 ref 引用需要检测位置变化的父容器 1234567&lt;div ref={ref} style={{ background: `hsl(${hsva.h}, 100%, 50%)` }} className=\"saturation\"&gt; ...&lt;/div&gt; 这样 pos 就可以获取鼠标拖动在父容器的坐标 useMouseDrag 具体实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061interface IPosition { offsetX: number; offsetY: number;}export function useMouseDrag&lt;T extends HTMLElement&gt;( element: T | null): [RefObject&lt;T&gt;, IPosition, Dispatch&lt;SetStateAction&lt;IPosition&gt;&gt;] { const ref = useRef&lt;T&gt;(element); const [start, toggle] = useToggle(false); const [pos, setPos] = useState&lt;IPosition&gt;({ offsetX: 0, offsetY: 0 }); const setPosition = useMemo( () =&gt; throttle(({ clientX, clientY }: MouseEvent) =&gt; { const element = ref.current; if (!element) return; const { left, top } = element.getBoundingClientRect(); const offsetX = clamp(clientX - left, 0, element.clientWidth); const offsetY = clamp(clientY - top, 0, element.clientHeight); setPos({ offsetX, offsetY }); }, 40), [] ); const startDrag = useCallback( (event: MouseEvent) =&gt; { setPosition(event); toggle(true); }, [toggle, setPosition] ); const dragging = useCallback((event: MouseEvent) =&gt; setPosition(event), [ setPosition, ]); const stopDrag = useCallback(() =&gt; toggle(false), [toggle]); useEffect(() =&gt; { const element = ref.current; if (!element) return; element.addEventListener(\"mousedown\", startDrag); return () =&gt; { element.removeEventListener(\"mousedown\", startDrag); }; }, [startDrag]); useEffect(() =&gt; { const element = ref.current; if (!element || !start) return; element.addEventListener(\"mousemove\", dragging); document.addEventListener(\"mouseup\", stopDrag); return () =&gt; { element.removeEventListener(\"mousemove\", dragging); document.removeEventListener(\"mouseup\", stopDrag); }; }, [start, dragging, stopDrag]); return [ref, pos, setPos];} 之后来构建色相拖动条，还是同样的套路，熟悉的配方 12345678910111213&lt;div style={{ width: `${width}px`, height: `${height}px` }} className=\"color-picker-wrapper color-picker-hue\"&gt; &lt;div ref={ref} className=\"hue\"&gt; &lt;div className=\"hue-thumb\" style={{ left: `${pos.offsetX}px`, }} /&gt; &lt;/div&gt;&lt;/div&gt; 通过指定关键颜色渐变形成色相环 12345678910111213141516171819202122232425262728.color-picker-hue { box-sizing: border-box; border-left: 4px solid #f00; border-right: 4px solid #f00; .hue { @include full(); background: linear-gradient( to right, #f00 0%, #ff0 16.66%, #0f0 33.33%, #0ff 50%, #00f 66.66%, #f0f 83.33%, #f00 100% ); .hue-thumb { position: absolute; width: 8px; height: 100%; background-color: #fff; box-shadow: 0 0 2px rgba(0, 0, 0, 0.6); transform: translateX(-4px); } }} 拖动的逻辑复用 useMouseDrag 同理透明度拖动条也是一样 1234567891011121314151617181920212223&lt;div style={{ width: `${width}px`, height: `${height}px`, borderRightColor: color, }} className=\"color-picker-wrapper color-picker-alpha\"&gt; &lt;div ref={ref} className=\"alpha\" style={{ background: `linear-gradient(to right, transparent, ${color})`, }} &gt; &lt;div className=\"alpha-thumb\" style={{ left: `${pos.offsetX}px`, }} /&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031.color-picker-alpha { box-sizing: border-box; border-left: 4px solid; border-left-color: transparent; border-right: 4px solid; background-color: white; background-image: linear-gradient( 45deg, #c5c5c5 25%, transparent 0, transparent 75%, #c5c5c5 0, #c5c5c5 ), linear-gradient(45deg, #c5c5c5 25%, transparent 0, transparent 75%, #c5c5c5 0, #c5c5c5); background-size: 10px 10px; background-position: 0 0, 5px 5px; .alpha { @include full(); .alpha-thumb { position: absolute; width: 8px; height: 100%; background-color: #fff; box-shadow: 0 0 2px rgba(0, 0, 0, 0.6); transform: translateX(-4px); } }} 这样通过计算拖动位置和宽度或高度的比值，就可以计算相应的 H、S、V 和 A 值，计算方式如下： 123456import { round } from \"lodash\";const s = round(pos.offsetX / element.clientWidth, 2);const v = round((element.clientHeight - pos.offsetY) / element.clientHeight, 2);const h = round((pos.offsetX / element.clientWidth) * 360);const a = round(pos.offsetX / element.clientWidth, 2); 为了显示获得 HSV 值，将其转换为了 HSL（CSS 支持 HSL 而不是 HSV）作为 div 的 CSS 样式 1234567const hsl = hsv2hsl(hsva);const color = `hsl(${hsva.h}, ${hsl.s * 100}%, ${hsl.l * 100}%)`;&lt;div style={{ backgroundColor: color, opacity: `${hsva.a * 100}%` }} className=\"color-picker-block\"/&gt;; HSV 转 HSL 的公式网上也能随便找到 1234567const hsv2hsl = ({ h, s, v }: IHSVA): { h: number; s: number; l: number } =&gt; { return { h, s: round((s * v) / ((h = (2 - s) * v) &lt; 1 ? h : 2 - h) || 0, 2), l: round(h / 2, 2), };}; 这样任何颜色更改都会在这个 div 上生效 至此这个版本颜色选择器就搞定了，非常简单，但是对于我来说简单的东西想要做好做完美也很不容易。日常工作中不重复造轮子用于生产，但是通过构建简单版本的轮子来学习我认为很有必要。","link":"/2020/11/24/%E6%9E%84%E5%BB%BA%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%9A%84ColorPicker/"},{"title":"跨域产生原因和解决方法","text":"文章链接 为什么会跨域因为浏览器实现了同源策略：浏览器认为自任何站点装载的信赖内容是不安全的。当被浏览器半信半疑的脚本运行在沙箱时，它们应该只被允许访问来自同一站点的资源，而不是那些来自其它站点可能怀有恶意的资源。同源意为域名、协议、端口相同。 举个例子，相较于http://localhost:8080/index.html 地址 结果 原因 https://localhost:8080/user 失败 协议不同 http://127.0.0.1:8080/user 失败 域名不同 http://localhost:8081/user 失败 端口不同 http://localhost:8080/user 成功 完全相同 存在同源策略的意义同源策略主要体现在以下两方面的限制： DOM 访问：禁止对不同源页面 DOM 进行操作。这里主要场景是 iframe 跨域的情况，不同域名的 iframe 是限制互相访问的。 Ajax 请求：禁止使用 XHR 对象向不同源的服务器地址发起 HTTP 请求。 如果不限制 DOM 访问的情况 做一个假网站，里面用 iframe 嵌套一个银行网站 http://mybank.com。 把 iframe 宽高啥的调整到页面全部，这样用户进来除了域名，别的部分和银行的网站没有任何差别。 这时如果用户输入账号密码，我们的主网站可以跨域访问到 http://mybank.com 的 dom 节点，就可以拿到用户的账户密码了。 如果不限制 Ajax 请求的情况 跨站请求伪造（CSRF） 用户登录了自己的银行页面 http://mybank.com，http://mybank.com 向用户的 cookie 中添加用户标识。 用户浏览了恶意页面 http://evil.com，执行了页面中的恶意 AJAX 请求代码。http://evil.com 向 http://mybank.com 发起 AJAX HTTP 请求，请求会默认把 http://mybank.com 对应 cookie 也同时发送过去。 银行页面从发送的 cookie 中提取用户标识，验证用户无误，响应恶意的请求。 如何解决跨域问题跨域资源共享（CORS）不会触发 CORS 预检请求（Preflight）的请求称为简单请求，满足以下条件： 满足以下请求方法： GET HEAD POST 不人为设置以下集合之外的请求头 Accept Accept-Language Content-Language Content-Type 仅限以下 text/plain multipart/form-data application/x-www-form-urlencoded DPR Downlink Save-Data Viewport-Width Width 请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器；XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。 请求中没有使用 ReadableStream 对象。 接下来代码演示 先启动第一个服务，返回一个页面 123456789101112131415161718import http from 'http';import fs from 'fs';const server = http.createServer( (req: http.IncomingMessage, res: http.ServerResponse) =&gt; { console.log(`${req.method} =&gt; ${req.url}`); const html = fs.readFileSync('./src/index.html', 'utf-8'); res.writeHead(200, { 'Content-Type': 'text/html', }); res.end(html); },);const host = 'localhost';const port = 4000;console.log(`Start server on ${host}:${port}`);server.listen(port, host); 在页面中发送一个 ajax 请求 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;title&gt;index&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello World!&lt;/h1&gt; &lt;script&gt; fetch('http://localhost:4001', { method: 'PUT', }); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 然后启动另外一个服务响应页面中的请求 123456789101112131415161718import http from 'http';const server = http.createServer( (req: http.IncomingMessage, res: http.ServerResponse) =&gt; { console.log(`${req.method} =&gt; ${req.url}`); res.writeHead(200, { 'Content-Type': 'application/json', // 'Access-Control-Allow-Origin': '*', // 'Access-Control-Allow-Methods': 'PUT', }); res.end(JSON.stringify({ message: 'Hello World!' })); },);const host = 'localhost';const port = 4001;console.log(`Start server on ${host}:${port}`);server.listen(port, host); 由于发送的是PUT请求，不属于简单请求，所以会发送预请求，查看浏览器Network可以看到OPTIONS请求 12345678// HeadersRequest URL: http://localhost:4001/Request Method: OPTIONSStatus Code: 200 OKRemote Address: 127.0.0.1:4001// Response{\"message\":\"Hello World!\"} 已经请求成功了，但是Console有报错 1Access to fetch at 'http://localhost:4001/' from origin 'http://localhost:4000' has been blocked by CORS policy: Method PUT is not allowed by Access-Control-Allow-Methods in preflight response. 浏览器忽略了成功的结果，抛出了错误。 为了能够跨域，需要给响应设置请求头 1234567891011{ // 允许的域，使用通配符，也可以指定 // \"Access-Control-Allow-Origin\": \"http://localhost:4000\", \"Access-Control-Allow-Origin\": \"*\", // 允许的方法，以逗号分隔 \"Access-Control-Allow-Methods\": \"PUT\", // 允许的自定义请求头，以逗号分隔 \"Access-Control-Allow-Headers\": \"X-Test-Cors\", // 将预请求缓存多长时间，以秒为单位 \"Access-Control-Max-Age\": 86400,} 重新测试，请求成功。 一旦服务器通过预请求允许该请求之后，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样了。 我的实践与文档不符：测试多次发送请求，每次请求之前都会额外发送一次 OPTIONS 请求，不知道哪里有问题？ 反向代理 node.js 中间件代理跨域原理类似 添加 nginx 配置，反向代理两个服务 123456789101112131415worker_processes 1;events { worker_connections 1024;}http { server { listen 8000; location / { proxy_pass http://localhost:4000/; } location ^~ /api { proxy_pass http://localhost:4001/; } }} 因为我本机装了 openresty，直接用以下命令启动 nginx 1234# 运行openresty -p `pwd`/ -c nginx.conf# 重启openresty -s reload -p `pwd`/ -c nginx.conf 因为已经都代理到 http://localhost:8000，所以要以相对路径发送请求 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;title&gt;index&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello World!&lt;/h1&gt; &lt;script&gt; fetch('/api', { method: 'PUT', }); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 测试通过。 window.postMessagewindow.postMessage(message, targetOrigin) 方法是 HTML5 新引进的特性，可以使用它来向其它的 window 对象发送消息，无论这个 window 对象是属于同源或不同源。这个应该就是以后解决 dom 跨域通用方法了。 WebsocketWebSocket protocol 是 HTML5 一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是 server push 技术的一种很好的实现。 JSONP由于 script 标签不受浏览器同源策略的影响，允许跨域引用资源。因此可以通过动态创建 script 标签，然后利用 src 属性进行跨域，这也就是 JSONP 跨域的基本原理。 location.hash + iframelocation.hash 方式跨域，是子框架修改父框架 src 的 hash 值，通过这个属性进行传递数据，且更改 hash 值，页面不会刷新。但是传递的数据的字节数是有限的。 window.name + iframewindow.name 属性的独特之处：name 值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。 document.domain + iframe仅限主域相同，子域不同的场景。 通过 JavaScript 强制设置 document.domain 为基础主域，就实现了同域。","link":"/2020/04/24/%E8%B7%A8%E5%9F%9F%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"},{"title":"面试笔试总结","text":"2020-03-29 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394type integer = number;// 指定数字M，获取数组中N个数字的和为M// 不允许重复function getNumbersSumEqualToTarget( numbers: integer[], m: integer, n: integer) { // 位运算位数不足用0补位 // 3 &amp; 1 =&gt; 1 // 统计数字中1的个数 function getCount(number: integer) { let count = 0; while (number) { number &amp;= number - 1; count++; } return count; } const len = numbers.length; // 所有结果 const res = []; for (let i = 0; i &lt; 1 &lt;&lt; len; i++) { // 满足选中数字个数时 if (getCount(i) == n) { let sum = 0; // 索引数组 let tmp = []; for (let j = 0; j &lt; len; j++) { // 是否是选中数字 if (i &amp; (1 &lt;&lt; j)) { sum += numbers[j]; tmp.push(j); } } // 如果满足存到结果中 if (sum === m) { res.push(tmp); } } } return res;}// console.log(getNumbersSumEqualToTarget([1, 5, 2, 3, 4, 5, 6], 9, 2));// 数字添加千分位符号// 已有实现toLocaleStringconst input = 1234567890.123;// console.log(input.toLocaleString());function formatNumberWithThousandsSymbol(number: integer) { const [intStr, floatStr]: string[] = number.toString().split(\".\"); const intArr: string[] = []; for (let i = intStr.length - 1; i &gt;= 0; i--) { intArr.unshift(intStr[i]); // 如果位数是3的倍数且下一位有数添加分号 if ((intStr.length - i) % 3 === 0 &amp;&amp; i - 1 &gt;= 0) { intArr.unshift(\",\"); } } return [intArr.join(\"\"), floatStr || \"\"].join(\".\");}// console.log(formatNumberWithThousandsSymbol(input));// 找出字符串数组的公有前缀function getCommonPrefix(strings: string[]) { const firstString = strings[0]; let comLen: integer; // 遍历第一个字符串 // slice不包含右侧 for (let i = 1; i &lt;= firstString.length; i++) { comLen = i; let out = false; // 遍历整个字符串数组 for (let j = 0; j &lt; strings.length; j++) { // 如果任意一个不同退出循环 if (strings[j].slice(0, comLen) !== firstString.slice(0, comLen)) { out = true; break; } } // 退出整个循环，并且comLen减一 if (out) { comLen--; break; } } return firstString.slice(0, comLen);}// const inputs = [\"abc\", \"abcd\", \"abce\", \"abcf\", \"ab\", \"a\"];// const commonPrefix = getCommonPrefix(inputs);// console.log(commonPrefix);","link":"/2020/03/31/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95%E6%80%BB%E7%BB%93/"},{"title":"生成器实现异步转同步","text":"使用方式如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function asyncGenerator(fn: (...args: any[]) =&gt; any) { return function (...args: any[]) { // 获取生成器对象 const gen = fn.apply(this, args); return new Promise((resolve, reject) =&gt; { let res; const nextStep = (value: any = undefined) =&gt; { try { res = gen.next(value); if (res.done) { // 生成器return的结果作为Promise的值 // * res.value为return值 resolve(res.value); } else { // 包裹一层Promise，递归调用next直到done // * res.value为yield值 Promise.resolve(res.value).then(nextStep); } } catch (err) { // 异常抛出 reject(err); } }; // 迭代第一次 nextStep(); }); };}function* run(a: any) { const b = yield new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve(2); }, 1000); }); const c = 3; const d = yield new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve(4); }, 100); }); return [a, b, c, d];}asyncGenerator(run)(1).then((res) =&gt; { console.log(res); // [1, 2, 3, 4]});","link":"/2020/05/06/%E7%94%9F%E6%88%90%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E8%BD%AC%E5%90%8C%E6%AD%A5/"},{"title":"Rust学习导图","text":"","link":"/2019/11/18/RUST/Rust%E5%AD%A6%E4%B9%A0%E5%AF%BC%E5%9B%BE/"},{"title":"Rust的字符串","text":"Rust中str、&amp;str、String和&amp;String的区别和关系 先看看Rust创建字符串String常用的三种方法： 123let s1 = \"hello\".to_string();let s2 = String::from(\"hello\");let s3 = format!(\"hello\"); 凭我们的直观”hello”本来就是一个字符串了，为什么还需要这么复杂的？也许这样更好： 1let s1 = \"hello\"; 但在clion中会提示我们s是一个&amp;str类型，Rust出于什么原因做这样的区分？这两个类型又有什么不同？ str是存在内存中的动态长度的utf-8不可变序列，由于大小未知&lt;?&gt;，因此只能使用指针处理它，使用&amp;str访问值 &amp;str对某些utf-8数据的引用，通常称为”字符串切片”，它只是某些数据的视图，数据可以存储在任何地方： 静态存储：字符串字面量”hello”是&amp;’static str，程序运行时，数据被硬编码到可执行文件并加载到内存中 1let s1 = \"hello\"; 指向堆上的String：对String类型变量进行切片，&amp;str获取其数据视图（借用） 1let s2 = &amp;String::from(\"hello\")[..] 栈 123use std::str;let s3: &amp;str = str::from_utf8(&amp;[b'h', b'e', b'l', b'l', b'o']).unwrap(); String是具有所有权的动态字符串，分配在堆上，和Vec类似，当你需要拥有或修改数据时使用它 &amp;String是对于String的借用，本质上是一个指针。通常可以被强制隐式转换为&amp;str，所以很少直接使用 使用&amp;String的一种情况：将可变引用传递给需要修改字符串的函数 123456789fn main() { let mut s = String::from(\"Hello, Rust!\"); foo(&amp;mut s);}fn foo(s: &amp;mut String) { s.push_str(\"appending foo..\"); println!(\"{}\", s);} 参考资料： https://www.ameyalokare.com/rust/2017/10/12/rust-str-vs-String.html http://llever.com/gentle-intro/pain-points.zh.html https://blog.thoughtram.io/ownership-in-rust/","link":"/2019/11/21/RUST/Rust%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"title":"Rust的智能指针","text":"引用、指针和智能指针 Rust的引用就是指针，通过&amp;符号借用它们指向的值。除了引用数据外，它们没有任何其他特殊功能，也没有任何开销。 智能指针是充当指针的特殊数据结构，它具有相较于普通指针额外的元数据和拓展功能。 在Rust中，标准库定义的不同智能指针所提供的功能超出了引用所提供的功能，我们可以通过它们完成许多特定的功能。 Rust标准库中的智能指针Box&lt;T&gt;、Rc&lt;T&gt;和RefCell&lt;T&gt;介绍 Box&lt;T&gt;在栈上存储指针，在堆上存储数据。用来存储编译时无法确定大小的数据类型，例如引用自身的枚举定义： 1234enum List { Cons(i32, List), Nil,} Rust尝试计算List大小时，会陷入无限递归！通过Box&lt;T&gt;包裹可以安全的通过编译： 1234enum List { Cons(i32, Box&lt;List&gt;), Nil,} Rc&lt;T&gt;跟踪数据的引用数量。用来共享数据，实现多重所有权。 123let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));let b = Cons(3, Box::new(a));let c = Cons(4, Box::new(a)); 上面的代码很显然会抛出借用错误，因为转移了两次a的所有权，但是如果需求上非要满足b和c的后继节点是a，且它们都需要有a的所有权，那么不通过一点特殊的手段，在当前借阅规则下就无法实现。 1234567891011121314151617enum List { Cons(i32, Rc&lt;List&gt;), Nil,}use crate::List::{Cons, Nil};use std::rc::Rc;fn main() { let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil))))); // count = 1 let b = Cons(3, Rc::clone(&amp;a)); // count++ let c = Cons(4, Rc::clone(&amp;a)); // count++}// c count--// b count--// a count--// count = 0 通过Rc&lt;T&gt;对数据的不可变引用计数，当引用计数为0时，离开作用域会触发drop析构。 Rc&lt;T&gt;仅适用于不可变引用，如果你想要一个线程安全的替代品，请使用std::sync::Arc RefCell&lt;T&gt;实现内部可变性，并在运行时检查借阅规则。 通常情况，给定一个不可变值，无法获取它的可变引用，下面的代码无法通过编译： 12let x = 5;let y = &amp;mut x; 通过RefCell&lt;T&gt;就可以在运行时获取不可变值的可变引用 123456789101112131415161718192021222324252627#[derive(Debug)]enum List { Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;), Nil,}use crate::List::{Cons, Nil};use std::rc::Rc;use std::cell::RefCell;fn main() { let value = Rc::new(RefCell::new(5)); let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil))); let b = Cons(Rc::new(RefCell::new(6)), Rc::clone(&amp;a)); let c = Cons(Rc::new(RefCell::new(10)), Rc::clone(&amp;a)); *value.borrow_mut() += 10; // 5 + 10 = 15 println!(\"a after = {:?}\", a); // a after = Cons(RefCell { value: 15 }, Nil) println!(\"b after = {:?}\", b); // b after = Cons(RefCell { value: 6 }, Cons(RefCell { value: 15 }, Nil)) println!(\"c after = {:?}\", c); // c after = Cons(RefCell { value: 10 }, Cons(RefCell { value: 15 }, Nil))} Rust借阅规则？ At any given time, you can have either (but not both of) one mutable reference or any number of immutable references. References must always be valid. 编译时/运行时检查借阅规则的区别 With references and Box, the borrowing rules’ invariants are enforced at compile time. With RefCell, these invariants are enforced at runtime. With references, if you break these rules, you’ll get a compiler error. With RefCell, if you break these rules, your program will panic and exit. 使用Deref特质将智能指针视为常规引用12345678910111213141516171819202122232425struct MyBox&lt;T&gt;(T);impl&lt;T&gt; MyBox&lt;T&gt; { fn new(x: T) -&gt; MyBox&lt;T&gt; { MyBox(x) }}use std::ops::Deref;impl&lt;T&gt; Deref for MyBox&lt;T&gt; { type Target = T; fn deref(&amp;self) -&gt; &amp;T { &amp;self.0 // MyBox通过元组构造，取第一个元素的引用 }}fn main() { let x = 5; let y = MyBox::new(x); assert_eq!(5, x); assert_eq!(5, *y); // *(y.deref())只会发生一次，不会无限递归} 使用Drop Trait运行清理代码123456789101112131415struct CustomSmartPointer { data: String,}impl Drop for CustomSmartPointer { fn drop(&amp;mut self) { println!(\"Dropping CustomSmartPointer with data `{}`!\", self.data); }}fn main() { let c = CustomSmartPointer { data: String::from(\"my stuff\") }; let d = CustomSmartPointer { data: String::from(\"other stuff\") }; println!(\"CustomSmartPointers created.\");}","link":"/2019/11/21/RUST/Rust%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"},{"title":"3. 使用jwt认证","text":"完成接口目录和业务层级的布局之后，就可以开心的实现接口逻辑，主要围绕着数据库的增删改查实现，但是事实上通过接口所有人都可以访问，修改，删除数据库中的数据，这样十分危险，必须提供一种方式标识出访问者的身份，根据身份确定访问者是否可以访问，修改，删除对应的数据。 项目地址：https://github.com/defpis/build_restful_api_with_flask 本节实现的目标： 创建User表，提供用户注册，用户登录等接口，包含最基本的数据库操作 先实现使用jwt认证，授权将在之后介绍 参数解析 模型序列化 依赖安装 123456pipenv install flask_sqlalchemy # 数据库ormpipenv install flask-migrate # 数据库迁移pipenv install marshmallow-sqlalchemy # 模型序列化pipenv install flask-marshmallow # 模型序列化pipenv install webargs # 参数解析pipenv install flask-jwt-extended # jwt认证 在extensions.py中实例化插件 12345678910from flask_sqlalchemy import SQLAlchemyfrom flask_migrate import Migratefrom flask_jwt_extended import JWTManagerfrom flask_marshmallow import Marshmallowdb = SQLAlchemy()session = db.sessionmigrate = Migrate()jwt = JWTManager()ma = Marshmallow() 之后在create_app中初始化 12345678910111213141516...from .extensions import db, migrate, jwt, madef create_app(env: str) -&gt; Flask: ... # extensions db.init_app(app) migrate.init_app(app, db) jwt.init_app(app) ma.init_app(app) ... return app 创建base.py定义抽象基类，抽离公用字段 app/api_v1/models/base.py 12345678910111213141516171819from sqlalchemy.ext.declarative import declared_attrfrom app.extensions import dbfrom app.utils import get_now, camel_to_underline, get_attr_on_gclass Base(db.Model): __abstract__ = True app_id = db.Column(db.Integer(), default=get_attr_on_g('app_id')) creator_id = db.Column(db.Integer(), default=get_attr_on_g('user_id')) created_time = db.Column(db.DateTime(), default=get_now) modifier_id = db.Column(db.Integer(), onupdate=get_attr_on_g('user_id')) last_updated_time = db.Column(db.DateTime(), onupdate=get_now) is_deleted = db.Column(db.Boolean(), default=False) # noinspection PyMethodParameters @declared_attr def __tablename__(cls) -&gt; str: return camel_to_underline(cls.__name__) 然后定义用户模型user.py app/api_v1/models/user.py 1234567891011121314151617181920212223242526272829from werkzeug.security import generate_password_hash, check_password_hashfrom app.extensions import jwtfrom app.errors import UserNotExistedfrom .base import Base, dbclass User(Base): id = db.Column(db.Integer(), primary_key=True) username = db.Column(db.String(64), unique=True, index=True, nullable=False) password_hash = db.Column(db.String(128), nullable=False) @property def password(self) -&gt; None: raise AttributeError('password is not a readable attribute') @password.setter def password(self, password: str) -&gt; None: self.password_hash = generate_password_hash(password) def verify_password(self, password: str) -&gt; bool: return check_password_hash(self.password_hash, password) @staticmethod @jwt.user_loader_callback_loader def get_current_user(user_id): user = User.query.filter_by(id=user_id, is_deleted=False).first() if not user: raise UserNotExisted() return user 在app/api_v1/models/__init__.py中导出模型 app/api_v1/models/__init__.py 1from .user import User 修改configs.py，添加数据库配置 1234567class SqlalchemyConfig: SQLALCHEMY_DATABASE_URI = f\"sqlite:///{ROOT_PATH}/db.sqlite\" SQLALCHEMY_TRACK_MODIFICATIONS = Trueclass DevelopmentConfig(BasicConfig, SqlalchemyConfig): ... 代码编写完成，开始创建数据库表，在项目根目录下执行 123flask db initflask db migrateflask db upgrade 通过PyCharm自带的工具连接sqlite查看表 数据库表生成好了，开始编写注册逻辑 在resources下新建一个auth目录存放认证相关接口 app/api_v1/resources 123456789.├── __init__.py├── auth│&nbsp;&nbsp; ├── __init__.py│&nbsp;&nbsp; ├── login.py│&nbsp;&nbsp; └── register.py└── demo ├── __init__.py └── greet.py 先创建注册接口（相关依赖查看项目代码自己修复） app/api_v1/resources/auth/register.py 123456789101112131415161718192021222324252627282930from typing import Dict, Anyfrom flask_marshmallow import Schemafrom flask_restful import Resourcefrom marshmallow import INCLUDEfrom app.core import parse, fieldsfrom app.extensions import sessionfrom app.api_v1.schemas import UserSchemaclass RegisterSchema(Schema): username = fields.String(required=True, error_messages={'required': '用户名是必要的'}) password = fields.String(required=True, error_messages={'required': '密码是必要的'})class RegisterResource(Resource): schema = UserSchema(exclude=('password_hash',)) @parse(RegisterSchema) def get(self, data: Dict) -&gt; Any: return self._register(data) @parse(RegisterSchema) def post(self, data: Dict) -&gt; Any: return self._register(data) def _register(self, data: Dict) -&gt; Dict: user = self.schema.load(data, unknown=INCLUDE) session.add(user) session.commit() return self.schema.dump(user) 然后创建登录接口 app/api_v1/resources/auth/login.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from typing import Dict, Anyfrom flask_restful import Resourcefrom flask_jwt_extended import create_access_token, create_refresh_tokenfrom flask_marshmallow import Schemafrom app.core import parse, fieldsfrom app.errors import UserNotExisted, PasswordInvalidfrom app.api_v1.models import Userfrom app.api_v1.schemas import UserSchemaclass AuthenticateMixin(object): @staticmethod def authenticate(username: str, password: str) -&gt; User: user = User.query.filter_by(username=username, is_deleted=False).first() if not user: raise UserNotExisted() if not user.verify_password(password): raise PasswordInvalid() return user @staticmethod def obtain_token(user: User) -&gt; Dict: return dict( access_token=create_access_token(identity=user.id), refresh_token=create_refresh_token(identity=user.id) )class LoginSchema(Schema): username = fields.String(required=True, error_messages={'required': '用户名是必要的'}) password = fields.String(required=True, error_messages={'required': '密码是必要的'})class LoginResource(Resource, AuthenticateMixin): schema = UserSchema(exclude=('password_hash',)) @parse(LoginSchema) def get(self, data: Dict) -&gt; Any: return self._login(data) @parse(LoginSchema) def post(self, data: Dict) -&gt; Any: return self._login(data) def _login(self, data: Dict) -&gt; Any: user = self.authenticate(data['username'], data['password']) return dict( **self.schema.dump(user), **self.obtain_token(user) ) 需要定义UserSchema来序列化和反序列化，绑定当前的session对象，使之load回来的对象是orm的实例 app/api_v1/schemas/user.py 12345678from app.extensions import ma, sessionfrom ..models import Userclass UserSchema(ma.ModelSchema): class Meta: model = User sqla_session = session 最后依次往上注册路由 app/api_v1/resources/auth/__init__.py 12345678from app.core import Routerfrom . import login, registerrouter = Router(decorators=[])router.url( (('/login', '/obtain_token'), login.LoginResource, {\"endpoint\": \"login\"}), ('/register', register.RegisterResource, {\"endpoint\": \"register\"}),) app/api_v1/resources/__init__.py 12345678from app.core import Routerfrom . import demo, authrouter = Router(decorators=[])router.url( ('/demo', demo.router), ('/auth', auth.router),) 参数解析使用到了库webargs，在app.core中定义了模块fields.py和parser.py app/core/fields.py 12from marshmallow.fields import *from webargs.fields import Nested # type: ignore app/core/parser.py 123456789101112131415from typing import Dict, Callablefrom functools import partialfrom marshmallow import Schemafrom marshmallow.exceptions import ValidationErrorfrom webargs.flaskparser import parserfrom flask import Requestfrom app.errors import ValidateError@parser.error_handlerdef handle_error(error: ValidationError, req: Request, schema: Schema, status_code: int, headers: Dict) -&gt; None: raise ValidateError(**error.messages) from error # type: ignoreparse: Callable = partial(parser.use_args, locations=('querystring', 'json')) app/core/__init__.py 123...from .parser import parsefrom . import fields 自定义异常在app/errors.py中 app/errors.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from typing import Dict, Typefrom flask import Flask, jsonifyfrom .log import log_errorclass CustomErrorHandler(object): def __init__(self): self.custom_errors = [] def __call__(self, error_class: Type['CustomError']): self.custom_errors.append(error_class) return error_class def init_app(self, app: Flask): for error_class in self.custom_errors: error_handler = log_error(error_class.generate_response) app.errorhandler(error_class)(error_handler)custom_error_handler = CustomErrorHandler()@custom_error_handlerclass CustomError(Exception): code = 500 message = \"自定义错误\" errors: Dict = {} def __init__(self, **kwargs): self.errors = kwargs def generate_response(self): resp_dict = { 'message': self.message } if self.errors: resp_dict['errors'] = self.errors return jsonify(resp_dict), self.code@custom_error_handlerclass UserNotExisted(CustomError): code = 404 message = \"用户不存在或已删除\"@custom_error_handlerclass PasswordInvalid(CustomError): code = 400 message = \"密码不合法\"@custom_error_handlerclass ValidateError(CustomError): code = 400 message = \"参数不合法\" 需要在create_app中注册 12345678910...from .errors import custom_error_handlerdef create_app(env: str) -&gt; Flask: ... custom_error_handler.init_app(app) return app 还需要配置一下jwt 1234567891011121314151617class JwtConfig: JWT_SECRET_KEY = \"you-will-never-guess\" JWT_ERROR_MESSAGE_KEY = \"message\" JWT_ACCESS_TOKEN_EXPIRES = timedelta(days=1) # access_token有效期1天 JWT_REFRESH_TOKEN_EXPIRES = timedelta(days=30) # refresh_token有效期30天 JWT_COOKIE_CSRF_PROTECT = False JWT_CSRF_IN_COOKIES = True JWT_ACCESS_COOKIE_PATH = \"/\" JWT_REFRESH_COOKIE_PATH = \"/\" JWT_ACCESS_CSRF_HEADER_NAME = \"X-CSRF-TOKEN\" JWT_REFRESH_CSRF_HEADER_NAME = \"X-CSRF-TOKEN\" JWT_TOKEN_LOCATION = [\"headers\", \"cookies\", \"query_string\", \"json\"] JWT_CSRF_METHODS = [\"POST\", \"PUT\", \"PATCH\", \"DELETE\"] JWT_BLACKLIST_ENABLED = Falseclass DevelopmentConfig(BasicConfig, SqlalchemyConfig, JwtConfig): ... 测试注册接口 测试登录接口 在我们的demo接口上添加jwt_required装饰器验证jwt app/api_v1/schemas/__init__.py 123456789from app.core import Routerfrom . import demo, authfrom flask_jwt_extended import jwt_requiredrouter = Router(decorators=[])router.url( ('/demo', demo.router, [jwt_required]), ('/auth', auth.router),) 访问http://127.0.0.1:5000/v1/demo/hello 1234{ \"request_id\": \"7c9cbc53-bd25-46ab-9a17-cbb1c7dd91c0\", \"message\": \"Missing Authorization Header\"} 为此接口添加之前登录返回的token，再次请求成功获取结果 下一节将介绍使用flask_sqlalchemy完成复杂查询。","link":"/2019/11/03/%E4%BD%BF%E7%94%A8flask%E5%88%9B%E5%BB%BArestful%E9%A3%8E%E6%A0%BC%E6%8E%A5%E5%8F%A3/%E4%BD%BF%E7%94%A8jwt%E8%AE%A4%E8%AF%81/"},{"title":"2. 基础架构（二）","text":"继续工程布局之前先介绍一个工具mypy。 mypy是一款针对python的静态类型检查程序。通过它，我们的python代码同时具备了动态类型灵活和静态类型安全的优点。 1pipenv install mypy --dev 检查app目录下文件的类型标注情况 1mypy app 如果提示”Cannot find module named ‘flask_restful’”，在根目录创建mypy.ini，写入内容： 12[mypy]ignore_missing_imports = true 再次运行命令检查错误消失，不能正确处理包导入应该是虚拟环境的问题 接下来继续布局工程，记录日志到文件和控制台，创建app/log.py输入： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from typing import Callable, Anyfrom time import strftime, localtime, timefrom uuid import uuid4from traceback import format_excfrom logging import Filter, Logger, Formatter, StreamHandler, INFOfrom logging.handlers import TimedRotatingFileHandlerfrom flask import current_app, g, has_request_contextfrom .configs import ROOT_PATHdef bind_request_id() -&gt; None: g.request_id = str(uuid4())def get_request_id() -&gt; str: if not hasattr(g, 'request_id'): bind_request_id() return g.request_idclass RequestIdFilter(Filter): def filter(self, record) -&gt; bool: record.request_id = get_request_id() if has_request_context() else '----' return Truedef log_error(func: Callable): def log_func(error: Exception) -&gt; Any: current_app.logger.error(format_exc()) return func(error) return log_funcdef add_console_handler(logger: Logger) -&gt; None: stream_handler = StreamHandler() stream_handler.setFormatter(Formatter( '%(request_id)s - %(asctime)s - %(levelname)s - %(filename)s - %(funcName)s - %(lineno)s - %(message)s')) stream_handler.addFilter(RequestIdFilter()) stream_handler.setLevel(INFO) logger.addHandler(stream_handler)def add_file_handler(logger: Logger) -&gt; None: dir_path = ROOT_PATH / 'logs' if not dir_path.exists(): dir_path.mkdir() file_path = dir_path / (strftime('%Y-%m-%d', localtime(time())) + '.log') file_handler = TimedRotatingFileHandler(file_path, 'D', 1, 7, None, False, False) file_handler.setFormatter(Formatter( '%(request_id)s - %(asctime)s - %(levelname)s - %(filename)s - %(funcName)s - %(lineno)s - %(message)s')) file_handler.addFilter(RequestIdFilter()) file_handler.setLevel(INFO) logger.addHandler(file_handler) 日志中定义了request_id需要在每次请求时绑定到flask的g对象上，所以创建一个中间件拦截每次请求，创建app/middlewares.py 12345678910111213141516from flask import current_app, request, g, Responsefrom .log import bind_request_iddef log_request_info() -&gt; None: bind_request_id() current_app.logger.info({ 'method': request.method, 'url': request.url, })def attach_request_id(response: Response) -&gt; Response: if isinstance(response.get_json(), dict): response.data = response.data.replace(b'{', bytes('{\\n \"request_id\":\"%s\",' % g.request_id, 'utf-8'), 1) return response 上面还增加一个中间件”attach_request_id”在json响应中添加request_id，在app/__init__.py中注册中间件和日志处理： 12345678910111213141516171819202122...from flask.logging import default_handlerfrom .log import add_console_handler, add_file_handlerfrom .middlewares import log_request_info, attach_request_iddef create_app(env: str) -&gt; Flask: ... # log logger = app.logger logger.removeHandler(default_handler) add_console_handler(logger) add_file_handler(logger) # middleware app.before_request(log_request_info) app.after_request(attach_request_id) ... return app 运行服务，发送请求，可以在更目录下看到logs目录生成，里面有当天的日志文件 在app目录下创建errors.py、extensions.py、utils.py分别对应自定义错误处理、插件、工具函数模块： 1234567891011121314.├── Pipfile├── Pipfile.lock├── app│&nbsp;&nbsp; ├── __init__.py│&nbsp;&nbsp; ├── configs.py│&nbsp;&nbsp; ├── errors.py│&nbsp;&nbsp; ├── extensions.py│&nbsp;&nbsp; ├── log.py│&nbsp;&nbsp; ├── middlewares.py│&nbsp;&nbsp; └── utils.py├── logs├── main.py└── mypy.ini 接下来布局业务所需的接口目录，我们通过蓝本管理和区分接口的版本，在app下创建api_v1包，在其__init__.py中定义蓝本： 123from flask import Blueprintblueprint = Blueprint('v1', __name__, url_prefix='/v1') 在api_v1下继续创建目录models、resources、schemas、initialize分别用于存放模型文件、接口文件、序列化文件和初始化文件 由于flask_restful提供的Api对象不可以嵌套注册路由，我在它基础上重新封装了一个Router对象 app/core/router.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from typing import Type, List, Tuplefrom flask import Blueprintfrom flask_restful import Api, Resourceclass Router(object): def __init__(self, prefix: str = '', decorators: List = None): self.prefix: str = prefix self.resources: List = [] self.children: List = [] self.decorators: List = decorators or [] def add_resource(self, view_class: Type[Resource], *urls, **options) -&gt; None: self.resources.append([view_class, urls, options]) def add_child_router(self, router: 'Router', prefix: str = '', decorators: List = None) -&gt; None: self.children.append((router, prefix, decorators or [])) def bind(self, blueprint: Blueprint) -&gt; None: def recurse(router, prefix: str = '', decorators: List = None) -&gt; None: prefix = prefix + router.prefix decorators = router.decorators[::-1] + (decorators or []) api = Api(blueprint, prefix='', decorators=decorators) for view_class, urls, options in router.resources: urls = [prefix + url for url in urls] api.add_resource(view_class, *urls, **options) for child_router, child_prefix, child_decorators in router.children: recurse(child_router, prefix + child_prefix, child_decorators[::-1] + decorators) recurse(self) def url(self, *options: Tuple) -&gt; None: for option in options: if len(option) == 2 and isinstance(option[1], Router): prefix, router = option self.add_child_router(router, prefix) if len(option) == 3 and isinstance(option[1], Router): prefix, router, decorators = option self.add_child_router(router, prefix, decorators) if len(option) == 2 and isinstance(option[1], type(Resource)): url, resource = option if isinstance(url, tuple) or isinstance(url, list): self.add_resource(resource, *url) else: self.add_resource(resource, url) if len(option) == 3 and isinstance(option[1], type(Resource)): url, resource, kwargs = option if isinstance(url, tuple) or isinstance(url, list): self.add_resource(resource, *url, **kwargs) else: self.add_resource(resource, url, **kwargs) 提供了主要三个方法： add_resource(self, view_class: Type[Resource], *urls, **options) - 注册接口和flask_restful的add_resource一致 add_child_router(self, router: ‘Router’, prefix: str = ‘’, decorators: List = None) - 注册子路由模块 bind(self, blueprint: Blueprint) - 绑定对象上的所有路由到蓝图 url(self, *options: Tuple) - 提供注册路由的通用方式 根据业务需求建立文件目录，假设我们需要创建一个hello接口 app/api_v1/resources 12345.├── __init__.py├── demo &nbsp;&nbsp; ├── __init__.py &nbsp;&nbsp; └── greet.py # HelloResource app/api_v1/resources/demo/greet.py 123456789from typing import Anyfrom flask_restful import Resourceclass HelloResource(Resource): def get(self) -&gt; Any: return { \"message\": \"Hello VimCoding!\" } app/api_v1/resources/demo/__init__.py 1234567from app.core import Routerfrom . import greetrouter = Router(decorators=[])router.url( ('/hello', greet.HelloResource, {\"endpoint\": \"hello\"}),) app/api_v1/resources/__init__.py 1234567from app.core import Routerfrom . import demorouter = Router(decorators=[])router.url( ('/demo', demo.router),) 修改app/api_v1/__init__.py 123456from flask import Blueprintfrom . import models, schemas, initializefrom .resources import routerblueprint = Blueprint('v1', __name__, url_prefix='/v1')router.bind(blueprint) 修改app/__init__.py 1234567891011...from . import api_v1def create_app(env: str) -&gt; Flask: ... # blueprint app.register_blueprint(api_v1.blueprint) return app 运行服务，使用Postman以GET方式访问http://localhost:5000/v1/demo/hello可以收到json格式响应。 1234{ \"request_id\": \"d2af0575-8973-444f-bbc1-25fa47a1b20d\", \"message\": \"Hello VimCoding!\"} 这样处理接口目录就和业务层级同步","link":"/2019/11/02/%E4%BD%BF%E7%94%A8flask%E5%88%9B%E5%BB%BArestful%E9%A3%8E%E6%A0%BC%E6%8E%A5%E5%8F%A3/%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89/"},{"title":"数组去重","text":"三种方式去除数组中的重复元素 使用集合Set 123const arr = [1, 2, 2, 3];console.log([...new Set(arr)]);console.log(Array.from(new Set(arr))); 使用数组方法filter 12const arr = [1, 2, 2, 3];console.log(arr.filter((item, index) =&gt; arr.indexOf(item) === index)); 使用数组方法reduce 12const arr = [1, 2, 2, 3];console.log(arr.reduce((unique, item) =&gt; unique.includes(item) ? unique : [...unique, item], []));","link":"/2020/01/13/%E5%89%8D%E7%AB%AF/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/"},{"title":"习惯的重要","text":"叶圣陶先生说：“教育就是培养习惯。”培根说：“习惯是一种顽强而巨大的力量，他可以主宰人生。”陶行知说：“思想决定行动，行动养成习惯，习惯形成品质，品质决定命运。” 由此可见，好的习惯不仅对学习，还有对生活都是有极大作用的。由于昨晚的没有休息好，今早起来想要做的事情没有完成，中午午觉又耽搁了很久的时间，不由的想起，自己作为一名教育者，如果都没有养成好的习惯，如何去教导和引导学生有一个好习惯呢？ 所以目前能慢慢改变的是 对于要解决的事情先用便利贴写清楚有几点，然后给予每一件事情完成所需时间的设定，尽量在规定时间内完成，一是可以改变拖延的习惯，二是塑造自己的成就感； 周末的时间要合理安排，玩耍的同时还要注意学习；对周末要完成的事情一定不能拖； 最令我困扰的是周中除了上班的时间外，回到家将如何让自己再学习学习，回家晚是不可避开的…","link":"/2019/11/03/%E8%80%81%E5%A9%86%E5%A4%A7%E4%BA%BA%E7%9A%84%E5%8D%9A%E5%AE%A2/%E4%B9%A0%E6%83%AF%E7%9A%84%E9%87%8D%E8%A6%81/"},{"title":"1. 基础架构（一）","text":"使用pycharm初始化一个新工程，选择pipenv初始化python3.7虚拟环境 初始化完成后，将除Pipfile和Pipfile.lock之外的所有项目移除，创建一个名为app的Python Package，得到如下目录： 12345.├── Pipfile├── Pipfile.lock└── app └── __init__.py 在app/__init__.py中通过工厂函数创建Flask实例 1234567891011from flask import Flaskdef create_app() -&gt; Flask: app = Flask(__name__) @app.route('/') def hello_world(): return 'Hello World!' return app 在根目录创建一个项目的入口文件main.py 123456from app import create_appapp = create_app()if __name__ == '__main__': app.run() 点击绿色三角就可以直接运行了，如果需要开启debug模式，点击启动项中的Edit Configurations配置启动参数 重新启动配置生效 还可以通过配置文件配置应用，在app下创建configs.py 12345678910111213141516171819202122232425262728293031323334353637383940from typing import Typefrom pathlib import Pathfrom flask import ConfigROOT_PATH = Path(__file__).parents[1]class BasicConfig(Config): SECRET_KEY = 'you-will-never-guess'class DevelopmentConfig(BasicConfig): ENV = \"development\" TESTING = True DEBUG = Trueclass TestingConfig(BasicConfig): ENV = \"testing\" TESTING = True DEBUG = Falseclass ProductionConfig(BasicConfig): ENV = \"production\" TESTING = False DEBUG = Falsedef get_config_by_env(env: str) -&gt; Type[BasicConfig]: configs = { 'development': DevelopmentConfig, 'testing': TestingConfig, 'production': ProductionConfig } try: return configs[env] except KeyError as err: raise RuntimeError('配置不存在') from err 需要修改app/__init__.py 1234567891011121314from flask import Flaskfrom .configs import get_config_by_envdef create_app(env: str) -&gt; Flask: app = Flask(__name__) config = get_config_by_env(env) app.config.from_object(config) @app.route('/') def hello_world(): return 'Hello World!' return app 通过python main.py和flask run启动的区别？ 继续完善程序入口main.py 1234567891011121314151617181920212223242526272829303132from typing import Dictimport osimport clickfrom flask.cli import AppGroupfrom app import create_appenv = os.getenv('FLASK_ENV', 'development')app = create_app(env)app_cli = AppGroup('app', help='some commands work with app.')@app.shell_context_processordef make_shell_context() -&gt; Dict: return { \"app\": app }@app_cli.command('print')@click.argument('name')def print_app_attr_by_name(name) -&gt; None: \"\"\" $ flask app print config &lt;Config {...}&gt; \"\"\" print(getattr(app, name, None))app.cli.add_command(app_cli)if __name__ == '__main__': app.run() 现在开始使用第一个插件flask_restful，使用pipenv安装 1pipenv install flask_restful 下载太慢可以修改Pipfile中的url为https://pypi.douban.com/simple/ 在app.py中使用它 12345678910111213141516171819...from flask_restful import Api, Resourcedef create_app(env: str) -&gt; Flask: ... api = Api(app) @api.resource('/welcome') class WelcomeResource(Resource): def get(self): return { \"message\": \"Welcome VimCoding\" } ... return app 运行服务，使用Postman以GET方式访问http://localhost:5000/welcome可以收到json格式响应。 123{ \"message\": \"Welcome VimCoding\"}","link":"/2019/11/01/%E4%BD%BF%E7%94%A8flask%E5%88%9B%E5%BB%BArestful%E9%A3%8E%E6%A0%BC%E6%8E%A5%E5%8F%A3/%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"0. 任务计划","text":"使用flask搭建一个基础框架 使用sqlalchemy操作数据库","link":"/2019/10/31/%E4%BD%BF%E7%94%A8flask%E5%88%9B%E5%BB%BArestful%E9%A3%8E%E6%A0%BC%E6%8E%A5%E5%8F%A3/%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92/"},{"title":"4. 使用sqlalchemy查询","text":"使用jwt认证时，我们通过flask_sqlalchemy简单的操作了user表：注册用户-插入一条数据到user表；用户认证-从数据库查询username相匹配的一条用户记录，然后验证密码。实际生产中，可能会有更多的需求：对结果排序，更复杂的过滤条件，多表联结查询等等。本节我们将一起探讨使用orm工具sqlalchemy和flask_sqlalchemy来实现复杂的数据库操作。 首先按照以下关系创建表，我们不使用外键关系约束，因为对于高性能的业务，使用关系在级联操作的时候可能会带来性能的损耗。","link":"/2019/11/09/%E4%BD%BF%E7%94%A8flask%E5%88%9B%E5%BB%BArestful%E9%A3%8E%E6%A0%BC%E6%8E%A5%E5%8F%A3/%E4%BD%BF%E7%94%A8sqlalchemy%E6%9F%A5%E8%AF%A2/"},{"title":"这是我的第一篇博客","text":"记录今天学习的markdown语法 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级级标题 一级标题二级标题三级标题四级标题五级标题六级级标题123*斜体***加粗字体*****斜体加粗字体*** 斜体加粗字体斜体加粗字体 1[百度](http://www.baidu.com/) 百度 1![图片上传](https://i.loli.net/2019/11/02/Nu3RgtTMmbe2wlX.jpg) 1--- 123| 标题1 | 标题2 | 标题3 || ----- -- | ----- -- | -- ----- || 内容1 | 内容2 | 内容3 | 标题1 标题2 标题3 内容1 内容2 内容3 123456789* 无序列表1* 无序列表2 1. 有序列表1 2. 有序列表2 3. 有序列表3* 无序列表3 * 嵌套列表1 * 嵌套列表2 * 嵌套列表3 无序列表1 无序列表2 有序列表1 有序列表2 有序列表3 无序列表3 嵌套列表1 嵌套列表2 嵌套列表3","link":"/2019/11/02/%E8%80%81%E5%A9%86%E5%A4%A7%E4%BA%BA%E7%9A%84%E5%8D%9A%E5%AE%A2/%E7%86%9F%E6%82%89markdown%E8%AF%AD%E6%B3%95/"},{"title":"生活","text":"平淡是好？还是有新鲜感是好？因为今天感觉是忙碌了一天，但却什么事情都没有做，让我有一种繁琐的感觉，也觉得难受和压抑： 在上海的时候，觉得很忙，没有和他人相同的周六周末的休息时间，也没有很好的朋友，但也因为自己的懒散，及其不想一个人出门再走很远坐地铁，以至于每个星期的休息日我都窝在家里，买菜做饭玩手机成了休息的主要模式，渐渐的久了，越来越心烦和压抑，很害怕以后的生活都是这样；所以一直想回成都，回成都，觉得回家了就可以好很多，周末至少可以拿出一天出去踏踏青之类的… 所以当时的想法就是回成都成了唯一的念想，现在突然在家工作一段时间了，回想起之前的十一个周末，除了记得有一个阳光的午后，和俊俊哥哥逛青龙湖，走走闹闹散心是很开心的之外，很难再想起有什么美好的记忆… 是因为现在和朋友们的联系少了，或是年龄越大，缺少发现生活的开心…希望同平淡的人一起经历新鲜的事 ，这样便最好…","link":"/2019/11/17/%E8%80%81%E5%A9%86%E5%A4%A7%E4%BA%BA%E7%9A%84%E5%8D%9A%E5%AE%A2/%E7%94%9F%E6%B4%BB/"},{"title":"无声告白","text":"如何评价《无声告白》这本书？- 知乎","link":"/2019/12/27/%E9%98%85%E8%AF%BB/%E6%97%A0%E5%A3%B0%E5%91%8A%E7%99%BD/"}],"tags":[{"name":"MacOS","slug":"MacOS","link":"/tags/MacOS/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"}],"categories":[{"name":"周记","slug":"周记","link":"/categories/%E5%91%A8%E8%AE%B0/"},{"name":"Rust","slug":"Rust","link":"/categories/Rust/"},{"name":"使用flask创建restful风格接口","slug":"使用flask创建restful风格接口","link":"/categories/%E4%BD%BF%E7%94%A8flask%E5%88%9B%E5%BB%BArestful%E9%A3%8E%E6%A0%BC%E6%8E%A5%E5%8F%A3/"},{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"老婆大人","slug":"老婆大人","link":"/categories/%E8%80%81%E5%A9%86%E5%A4%A7%E4%BA%BA/"},{"name":"阅读","slug":"阅读","link":"/categories/%E9%98%85%E8%AF%BB/"}]}