<!DOCTYPE html>
<html class="has-navbar-fixed-top">
<head>
    <meta charset="utf-8">
<title>Pixi-in-Depth - Hexo</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.css">








    <meta name="description" content="pixi.js 部分源码解析">
<meta property="og:type" content="article">
<meta property="og:title" content="Pixi-in-Depth">
<meta property="og:url" content="https://defpis.github.io/2021/03/28/Pixi-in-Depth/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="pixi.js 部分源码解析">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-03-28T04:37:46.000Z">
<meta property="article:modified_time" content="2021-03-28T04:40:15.137Z">
<meta property="article:author" content="Defpis">
<meta name="twitter:card" content="summary">





<link rel="icon" href="/favicon.png">


<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ovo|Source+Code+Pro">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/bulma/0.6.2/css/bulma.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/css/justifiedGallery.min.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css">


<link rel="stylesheet" href="/css/style.css">


<script defer src="//use.fontawesome.com/releases/v5.0.8/js/all.js"></script>


    
    
    
    
    
    
    
    
    
    

    


<meta name="generator" content="Hexo 4.2.1"></head>
<body>
    
<nav class="navbar is-transparent is-fixed-top navbar-main" role="navigation" aria-label="main navigation">
    <div class="container">
        <div class="navbar-brand">
            <a class="navbar-item navbar-logo" href="/">
                
                <img src="/images/logo.png" alt="" height="28">
                
            </a>
            <div class="navbar-burger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
        
        <div class="navbar-menu navbar-start">
            
            <a class="navbar-item "
               href="/categories">分类</a>
            
            <a class="navbar-item "
               href="/tags">标签</a>
            
            <a class="navbar-item "
               href="/archives">归档</a>
            
            <a class="navbar-item "
               href="/about">关于我</a>
            
        </div>
        
        <div class="navbar-menu navbar-end">
            
            <a class="navbar-item search" title="搜索" href="javascript:;">
                <i class="fas fa-search"></i>
            </a>
            
            
            
            <a class="navbar-item" title="GitHub" href="https://github.com/defpis" target="_blank" rel="noopener">
                
                <i class="fab fa-github"></i>
                
            </a>
               
            
        </div>
    </div>
</nav>

    <section class="section">
    <div class="container">
    <article class="article content gallery" itemscope itemprop="blogPost">
    <h1 class="article-title is-size-3 is-size-4-mobile" itemprop="name">
        
            Pixi-in-Depth
        
    </h1>
    <div class="article-meta columns is-variable is-1 is-multiline is-mobile is-size-7-mobile">
        <span class="column is-narrow">
            <time datetime="2021-03-28T04:37:46.000Z" itemprop="datePublished">3月 28 2021</time>
        </span>
        
        
        <span class="column is-narrow">
            
            
            17 分钟 读完 (约 2599 字)
        </span>
        
    </div>
    <div class="article-entry is-size-6-mobile" itemprop="articleBody">
    
        <html><head></head><body><p>pixi.js 部分源码解析</p>
<a id="more"></a>

<h2 id="初始化应用"><a href="#初始化应用" class="headerlink" title="初始化应用"></a>初始化应用</h2><p>Application 主要完成以下任务：</p>
<ol>
<li>构建舞台 stage 作为渲染数据</li>
<li>构建渲染器 renderer 渲染 stage</li>
<li>依次调用 plugins 的 init 方法</li>
<li>暴露 render 方法，渲染一帧</li>
</ol>
<blockquote>
<p>packages/app/src/Application.ts</p>
</blockquote>
<p></p><figure class="highlight ts hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">class</span> Application{</span><br><span class="line">  <span class="hljs-keyword">public</span> stage: Container = <span class="hljs-keyword">new</span> Container();</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">constructor</span> {</span><br><span class="line">    <span class="hljs-keyword">this</span>.renderer = autoDetectRenderer(options);</span><br><span class="line">    Application._plugins.forEach(<span class="hljs-function">(<span class="hljs-params">plugin</span>) =&gt;</span> {</span><br><span class="line">      plugin.init.call(<span class="hljs-keyword">this</span>, options);</span><br><span class="line">    });</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  render() {</span><br><span class="line">    <span class="hljs-keyword">this</span>.renderer.render(<span class="hljs-keyword">this</span>.stage);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<h2 id="构建渲染循环"><a href="#构建渲染循环" class="headerlink" title="构建渲染循环"></a>构建渲染循环</h2><p>Application 通过调用 registerPlugin 往静态属性 _plugins 数组中存入插件</p>
<p>其中一个名为 TickerPlugin 的插件，用来专门处理 GameLoop</p>
<blockquote>
<p>bundles/pixi.js/src/index.ts</p>
</blockquote>
<p></p><figure class="highlight ts hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Application.registerPlugin(TickerPlugin);</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>进入 TickerPlugin 的 init 方法可以发现 Ticker 绑定了 render 方法</p>
<blockquote>
<p>packages/ticker/src/TickerPlugin.ts</p>
</blockquote>
<p></p><figure class="highlight ts hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// this 指向 Application 实例</span></span><br><span class="line"><span class="hljs-keyword">if</span> (ticker) {</span><br><span class="line">  ticker.add(<span class="hljs-keyword">this</span>.render, <span class="hljs-keyword">this</span>, UPDATE_PRIORITY.LOW);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>在探究 ticker.add 之前，先理解一下什么是 GameLoop，如果你使用过 canvas 绘制动画，对下面的代码一定不陌生：</p>
<p></p><figure class="highlight ts hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tick</span>(<span class="hljs-params"></span>) </span>{</span><br><span class="line">  requestAnimationFrame(tick);</span><br><span class="line">  <span class="hljs-comment">// animate</span></span><br><span class="line">})();</span><br></pre></td></tr></tbody></table></figure><p></p>
<blockquote>
<p>The window.requestAnimationFrame() method tells the browser that you wish to perform an animation and requests that the browser calls a specified function to update an animation before the next repaint. The method takes a callback as an argument to be invoked before the repaint.</p>
</blockquote>
<p>requestAnimationFrame 类似 setTimeout，tick 不断异步递归自己，相当于带间隔的死循环，每一帧调用，触发浏览器重绘</p>
<p>Ticker 做了类似的事情，只是额外增加了一些功能：</p>
<ul>
<li>维护了任务队列，可以按优先级排序</li>
<li>过滤或取消多余的绘制请求，防止过载</li>
<li>绑定回调自动启动渲染循环（autoStart===true）</li>
<li>提供 add 和 addOnce 来实现每次和单次执行</li>
<li>帧率控制，优化渲染最小帧率和最大帧率范围</li>
</ul>
<p>Ticker 在构造函数中创建了 _tick 作为每一帧的回调函数</p>
<blockquote>
<p>packages/ticker/src/Ticker.ts</p>
</blockquote>
<p></p><figure class="highlight ts hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">this</span>._tick = (time: <span class="hljs-built_in">number</span>): <span class="hljs-function"><span class="hljs-params">void</span> =&gt;</span> {</span><br><span class="line">  <span class="hljs-keyword">this</span>._requestId = <span class="hljs-literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.started) {</span><br><span class="line">    <span class="hljs-keyword">this</span>.update(time);</span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.started &amp;&amp; <span class="hljs-keyword">this</span>._requestId === <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">this</span>._head.next) {</span><br><span class="line">      <span class="hljs-keyword">this</span>._requestId = requestAnimationFrame(<span class="hljs-keyword">this</span>._tick);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p></p>
<ul>
<li>started 用于控制渲染循环的运行和退出</li>
<li>_head 以链表的方式组织所有回调任务</li>
<li>_requestId 来标记正在进行的渲染请求</li>
</ul>
<p>回调任务通过 add 和 addOnce 插入链表，它们都调用 _addListener 方法，只是构建的 TickerListener 传入参数有所区分</p>
<blockquote>
<p>packages/ticker/src/Ticker.ts</p>
</blockquote>
<p></p><figure class="highlight ts hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add&lt;T = <span class="hljs-built_in">any</span>&gt;(fn: TickerCallback&lt;T&gt;, context?: T, priority = UPDATE_PRIORITY.NORMAL): <span class="hljs-keyword">this</span> {</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._addListener(<span class="hljs-keyword">new</span> TickerListener(fn, context, priority));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">addOnce&lt;T = <span class="hljs-built_in">any</span>&gt;(fn: TickerCallback&lt;T&gt;, context?: T, priority = UPDATE_PRIORITY.NORMAL): <span class="hljs-keyword">this</span> {</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._addListener(<span class="hljs-keyword">new</span> TickerListener(fn, context, priority, <span class="hljs-literal">true</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>_addListener 通过遍历 _head 之后每个节点的 priority 属性来确定插入位置</p>
<blockquote>
<p>packages/ticker/src/Ticker.ts</p>
</blockquote>
<p></p><figure class="highlight ts hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> current = <span class="hljs-keyword">this</span>._head.next;</span><br><span class="line"><span class="hljs-keyword">let</span> previous = <span class="hljs-keyword">this</span>._head;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">while</span> (current) {</span><br><span class="line">  <span class="hljs-keyword">if</span> (listener.priority &gt; current.priority) {</span><br><span class="line">    listener.connect(previous);</span><br><span class="line">    <span class="hljs-keyword">break</span>;</span><br><span class="line">  }</span><br><span class="line">  previous = current;</span><br><span class="line">  current = current.next;</span><br><span class="line">}</span><br><span class="line"><span class="hljs-keyword">if</span> (!listener.previous) {</span><br><span class="line">  listener.connect(previous);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>TickerListener.connect 实现了链表插入</p>
<blockquote>
<p>packages/ticker/src/TickerListener.ts</p>
</blockquote>
<p></p><figure class="highlight ts hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">connect(previous: TickerListener): <span class="hljs-built_in">void</span> {</span><br><span class="line">  <span class="hljs-keyword">this</span>.previous = previous;</span><br><span class="line">  <span class="hljs-keyword">if</span> (previous.next) {</span><br><span class="line">    previous.next.previous = <span class="hljs-keyword">this</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="hljs-keyword">this</span>.next = previous.next;</span><br><span class="line">  previous.next = <span class="hljs-keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>在 Ticker.update 方法中会遍历回调任务链表，依次调用 TickerListener.emit</p>
<blockquote>
<p>packages/ticker/src/Ticker.ts</p>
</blockquote>
<p></p><figure class="highlight ts hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> head = <span class="hljs-keyword">this</span>._head;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">let</span> listener = head.next;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">while</span> (listener) {</span><br><span class="line">  listener = listener.emit(<span class="hljs-keyword">this</span>.deltaTime);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>在 TickerListener.emit 执行回调函数，并返回下一个节点</p>
<p>addOnce 会将 TickerListener.once 标记为 true，执行一次后会从链表中删除</p>
<blockquote>
<p>packages/ticker/src/TickerListener.ts</p>
</blockquote>
<p></p><figure class="highlight ts hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">emit(deltaTime: <span class="hljs-built_in">number</span>): TickerListener {</span><br><span class="line">  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.fn) {</span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.context) {</span><br><span class="line">      <span class="hljs-keyword">this</span>.fn.call(<span class="hljs-keyword">this</span>.context, deltaTime);</span><br><span class="line">    } <span class="hljs-keyword">else</span> {</span><br><span class="line">      (<span class="hljs-keyword">this</span> <span class="hljs-keyword">as</span> TickerListener&lt;<span class="hljs-built_in">any</span>&gt;).fn(deltaTime);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">const</span> redirect = <span class="hljs-keyword">this</span>.next;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.once) {</span><br><span class="line">    <span class="hljs-keyword">this</span>.destroy(<span class="hljs-literal">true</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> redirect;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>Ticker.update 还存在一段逻辑用于控制帧率逻辑，不过有点混乱，暂时略过</p>
<h2 id="构建舞台树"><a href="#构建舞台树" class="headerlink" title="构建舞台树"></a>构建舞台树</h2><p>初始化 Application 默认会创建 stage 作为舞台的根容器，之后所有需要渲染的对象都需要存储到它或它下属节点的 children 属性中，形成一颗舞台树</p>
<p>常见的方式是通过 addChild 把一个对象 push 到 Container.children 中</p>
<p></p><figure class="highlight ts hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> g = <span class="hljs-keyword">new</span> PIXI.Graphics();</span><br><span class="line">stage.addChild(g);</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>Graphics 本身也是 Container，所以可以在它的下面继续挂载节点</p>
<p>舞台上所有的对象以树形结构组织，渲染很自然变成了遍历整颗树，然后依次绘制每个物体的过程</p>
<p>每一个物体的绘制可以简单分为两部分（类似 DOM 绘制过程中的重排和重绘），一找到绘制的位置，二调用 API 绘制图像</p>
<p>对于第一个需求，每个对象可以从当前位置向上遍历至根节点，依次计算它们相对位置影响的总和，比如</p>
<p></p><figure class="highlight plain hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">            A</span><br><span class="line">  向x偏移10 /  \ 向x偏移-10</span><br><span class="line">          B   C</span><br><span class="line">向y偏移-10 |   | 向y偏移10</span><br><span class="line">          D   F</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>如果将 A 坐标系设为全局坐标系，原点为(0, 0)，D 遍历 D-&gt;B-&gt;A，得到 D 坐标系原点在 A 中为(10, -10)，A 原点在 D 中表示则为(-10, 10)</p>
<p>如果每个物体都这样计算，效率是极低的，况且很多时候 D 单独变化时，B-&gt;A 根本没变化，优化的思路就是为每一层级添加缓存</p>
<p></p><figure class="highlight plain hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">            A(0, 0)</span><br><span class="line">  向x偏移10 /  \ 向x偏移-10</span><br><span class="line">   (10, 0)B   C(-10, 0)</span><br><span class="line">向y偏移-10 |   | 向y偏移10</span><br><span class="line"> (10, -10)D   F(-10, 10)</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>如果 D 此时相对与父节点不是向 y 偏移 -10 而是向 y 偏移 10，那么可以很容易根据 B(10, 0) 重新计算得到 D(10, 10)</p>
<p>这样做还有一个优势就是非常容易的实现坐标在不同坐标系中的转换：</p>
<ul>
<li>假设 D 中有个点 P1(1, 1)，可以计算得到 P1 在 A 中的坐标为(11, -9)</li>
<li>假设 A 中有个点 P2(2, 2)，可以计算得到 P2 在 D 中的坐标为(-8, 12)</li>
</ul>
<p>Pixi 也是类似的思路，DisplayObject 上就有 Transform 对象负责管理和缓存位置变换信息，可以找到两个重要属性</p>
<blockquote>
<p>packages/math/src/Transform.ts</p>
</blockquote>
<p></p><figure class="highlight ts hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> worldTransform: Matrix;</span><br><span class="line"><span class="hljs-keyword">public</span> localTransform: Matrix;</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>对于 worldTransform 就类似 D 相对 A 的位置偏移(10, -10)，而 localTransform 就类似 <code>向y偏移-10</code> 可以表示为(0, -10)</p>
<p>节点的 worldTransform 总是通过它的父节点的 worldTransform 和它自己 localTransform 一起计算得到</p>
<p>缓存有了，何时更新缓存又是一个大问题！别着急，看看代码发现了几个计数器</p>
<blockquote>
<p>packages/math/src/Transform.ts</p>
</blockquote>
<p></p><figure class="highlight ts hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> _parentID: <span class="hljs-built_in">number</span>;</span><br><span class="line">_worldID: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// =&gt; _currentParentID</span></span><br><span class="line"><span class="hljs-keyword">protected</span> _localID: <span class="hljs-built_in">number</span>;</span><br><span class="line"><span class="hljs-keyword">protected</span> _currentLocalID: <span class="hljs-built_in">number</span>;</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>Pixi 通过计数器来确定上层或本层是否发生改变，本层或下层是否需要更新，四个计数器成队出现，两两比较值是否相等</p>
<blockquote>
<p>packages/math/src/Transform.ts</p>
</blockquote>
<p></p><figure class="highlight ts hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">updateTransform(parentTransform: Transform): <span class="hljs-built_in">void</span> {</span><br><span class="line">  <span class="hljs-keyword">const</span> lt = <span class="hljs-keyword">this</span>.localTransform;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._localID !== <span class="hljs-keyword">this</span>._currentLocalID) {</span><br><span class="line">      lt.a = <span class="hljs-keyword">this</span>._cx * <span class="hljs-keyword">this</span>.scale.x;</span><br><span class="line">      lt.b = <span class="hljs-keyword">this</span>._sx * <span class="hljs-keyword">this</span>.scale.x;</span><br><span class="line">      lt.c = <span class="hljs-keyword">this</span>._cy * <span class="hljs-keyword">this</span>.scale.y;</span><br><span class="line">      lt.d = <span class="hljs-keyword">this</span>._sy * <span class="hljs-keyword">this</span>.scale.y;</span><br><span class="line"></span><br><span class="line">      lt.tx = <span class="hljs-keyword">this</span>.position.x - ((<span class="hljs-keyword">this</span>.pivot.x * lt.a) + (<span class="hljs-keyword">this</span>.pivot.y * lt.c));</span><br><span class="line">      lt.ty = <span class="hljs-keyword">this</span>.position.y - ((<span class="hljs-keyword">this</span>.pivot.x * lt.b) + (<span class="hljs-keyword">this</span>.pivot.y * lt.d));</span><br><span class="line">      <span class="hljs-keyword">this</span>._currentLocalID = <span class="hljs-keyword">this</span>._localID;</span><br><span class="line"></span><br><span class="line">      <span class="hljs-keyword">this</span>._parentID = <span class="hljs-number">-1</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._parentID !== parentTransform._worldID) {</span><br><span class="line">      <span class="hljs-keyword">const</span> pt = parentTransform.worldTransform;</span><br><span class="line">      <span class="hljs-keyword">const</span> wt = <span class="hljs-keyword">this</span>.worldTransform;</span><br><span class="line"></span><br><span class="line">      wt.a = (lt.a * pt.a) + (lt.b * pt.c);</span><br><span class="line">      wt.b = (lt.a * pt.b) + (lt.b * pt.d);</span><br><span class="line">      wt.c = (lt.c * pt.a) + (lt.d * pt.c);</span><br><span class="line">      wt.d = (lt.c * pt.b) + (lt.d * pt.d);</span><br><span class="line">      wt.tx = (lt.tx * pt.a) + (lt.ty * pt.c) + pt.tx;</span><br><span class="line">      wt.ty = (lt.tx * pt.b) + (lt.ty * pt.d) + pt.ty;</span><br><span class="line"></span><br><span class="line">      <span class="hljs-keyword">this</span>._parentID = parentTransform._worldID;</span><br><span class="line"></span><br><span class="line">      <span class="hljs-keyword">this</span>._worldID++;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<ul>
<li>当前节点的 _localID 和当前节点的 _currentLocalID 配对，每当修改了位置状态，使 _localID 自增，以更新 localTransform，更新完成同步 _localID 和 _currentLocalID，并使当前节点的 _parentID 为 -1，以便继续更新当前节点的 worldTransform</li>
<li>当前节点的 _parentID 和上层节点的 _worldID 配对，如果不相等，更新当前节点的 worldTransform，同步当前节点的 _parentID 和上层节点的 _worldID，自增当前节点的 _worldID，以便继续更新下层节点的 worldTransform</li>
</ul>
<p>回到添加物体到舞台的过程，查看 addChild 源码</p>
<blockquote>
<p>packages/display/src/Container.ts</p>
</blockquote>
<p></p><figure class="highlight ts hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> (child.parent) {</span><br><span class="line">  child.parent.removeChild(child);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">child.parent = <span class="hljs-keyword">this</span>;</span><br><span class="line"><span class="hljs-keyword">this</span>.sortDirty = <span class="hljs-literal">true</span>;</span><br><span class="line"></span><br><span class="line">child.transform._parentID = <span class="hljs-number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">this</span>.children.push(child);</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>除了 push 到 children 数组，额外的工作就是设置 transform._parentID 为 -1，以便在渲染循环中更新变换矩阵</p>
<p>更新发生在每一帧都会调用的 Renderer.render 方法中，skipUpdateTransform 默认为 undefined</p>
<blockquote>
<p>packages/core/src/Renderer.ts</p>
</blockquote>
<p></p><figure class="highlight ts hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> (!skipUpdateTransform) {</span><br><span class="line">  <span class="hljs-keyword">const</span> cacheParent = displayObject.enableTempParent();</span><br><span class="line"></span><br><span class="line">  displayObject.updateTransform();</span><br><span class="line">  displayObject.disableTempParent(cacheParent);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>对于普通 DisplayObject 对象，updateTransform 仅仅更新它自己的状态</p>
<blockquote>
<p>packages/display/src/DisplayObject.ts</p>
</blockquote>
<p></p><figure class="highlight ts hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">updateTransform(): <span class="hljs-built_in">void</span> {</span><br><span class="line">  <span class="hljs-comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">this</span>.transform.updateTransform(<span class="hljs-keyword">this</span>.parent.transform);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>但是对于 Container 对象，继承 DisplayObject 重写了 updateTransform 方法</p>
<blockquote>
<p>packages/display/src/Container.ts</p>
</blockquote>
<p></p><figure class="highlight ts hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">updateTransform(): <span class="hljs-built_in">void</span> {</span><br><span class="line">  <span class="hljs-comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">this</span>.transform.updateTransform(<span class="hljs-keyword">this</span>.parent.transform);</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-keyword">this</span>.children.length; i &lt; j; ++i) {</span><br><span class="line">    <span class="hljs-keyword">const</span> child = <span class="hljs-keyword">this</span>.children[i];</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (child.visible) {</span><br><span class="line">      child.updateTransform();</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>Container.updateTransform 方法以深度优先顺序调用，更新所有受到影响的下属节点</p>
<p>舞台树所有节点的位置信息准备就绪，开始绘制！</p>
<h2 id="渲染到画布"><a href="#渲染到画布" class="headerlink" title="渲染到画布"></a>渲染到画布</h2><p>待舞台树位置更新完成后，会开始绘制</p>
<blockquote>
<p>packages/core/src/Renderer.ts</p>
</blockquote>
<p></p><figure class="highlight ts hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> (!skipUpdateTransform) {</span><br><span class="line">  <span class="hljs-keyword">const</span> cacheParent = displayObject.enableTempParent();</span><br><span class="line"></span><br><span class="line">  displayObject.updateTransform();</span><br><span class="line">  displayObject.disableTempParent(cacheParent);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">displayObject.render(<span class="hljs-keyword">this</span>);</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>DisplayObject.render 是一个抽象方法，并没有实现，查看 Container.render 的实现</p>
<blockquote>
<p>packages/display/src/Container.ts</p>
</blockquote>
<p></p><figure class="highlight ts hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">render(renderer: Renderer): <span class="hljs-built_in">void</span> {</span><br><span class="line">  <span class="hljs-comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">if</span> (<span class="hljs-comment">/* */</span>) {</span><br><span class="line">    <span class="hljs-comment">// ...</span></span><br><span class="line">  } <span class="hljs-keyword">else</span> {</span><br><span class="line">    <span class="hljs-keyword">this</span>._render(renderer);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-keyword">this</span>.children.length; i &lt; j; ++i) {</span><br><span class="line">      <span class="hljs-keyword">this</span>.children[i].render(renderer);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>Container.render 也是以深度优先顺序调用，具体过程由子类的 _render 方法实现</p>
<p>Graphics 继承于 Container，以它举例，定位到 Graphics._render 方法</p>
<blockquote>
<p>packages/graphics/src/Graphics.ts</p>
</blockquote>
<p></p><figure class="highlight ts hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="hljs-keyword">protected</span> _render(renderer: Renderer): <span class="hljs-built_in">void</span> {</span><br><span class="line">  <span class="hljs-keyword">this</span>.finishPoly();</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">const</span> geometry = <span class="hljs-keyword">this</span>._geometry;</span><br><span class="line">  <span class="hljs-keyword">const</span> hasuint32 = renderer.context.supports.uint32Indices;</span><br><span class="line"></span><br><span class="line">  geometry.updateBatches(hasuint32);</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">if</span> (geometry.batchable) {</span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.batchDirty !== geometry.batchDirty)</span><br><span class="line">    {</span><br><span class="line">        <span class="hljs-keyword">this</span>._populateBatches();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">this</span>._renderBatched(renderer);</span><br><span class="line">  }</span><br><span class="line">  <span class="hljs-keyword">else</span> {</span><br><span class="line">    renderer.batch.flush();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">this</span>._renderDirect(renderer);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>geometry.batchable 等于 true 为批处理逻辑，是为了提升性能做的优化，先不管这个分支，之后研究批处理系统时再深入</p>
<p>进入 Graphics._renderDirect 方法</p>
<blockquote>
<p>packages/graphics/src/Graphics.ts</p>
</blockquote>
<p></p><figure class="highlight ts hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">protected</span> _renderDirect(renderer: Renderer): <span class="hljs-built_in">void</span> {</span><br><span class="line">  <span class="hljs-comment">// ...</span></span><br><span class="line"></span><br><span class="line">  renderer.shader.bind(shader);</span><br><span class="line">  renderer.geometry.bind(geometry, shader);</span><br><span class="line"></span><br><span class="line">  renderer.state.set(<span class="hljs-keyword">this</span>.state);</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = drawCalls.length; i &lt; l; i++) {</span><br><span class="line">    <span class="hljs-keyword">this</span>._renderDrawCallDirect(renderer, geometry.drawCalls[i]);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>可以看到 renderer 绑定了 shader 和 geometry，还设置了状态，内部已经为开始绘制准备好了 WebGL 上下文 gl，现在只需根据生成的 drawCall 依次绘制即可，暂时忽略调用 WebGL API 绘制的过程，之后分析 Renderer 封装时详细研究</p>
<p>由于 geometry.drawCalls 和渲染的图形息息相关，为了查看它的信息，起了一个 demo，仅仅绘制一条线</p>
<blockquote>
<p>demo.ts</p>
</blockquote>
<p></p><figure class="highlight ts hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> <span class="hljs-string">"./index.scss"</span>;</span><br><span class="line"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> PIXI <span class="hljs-keyword">from</span> <span class="hljs-string">"pixi.js"</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> container = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">"#root"</span>)! <span class="hljs-keyword">as</span> HTMLDivElement;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> { renderer, stage, ticker } = <span class="hljs-keyword">new</span> PIXI.Application({</span><br><span class="line">  backgroundColor: <span class="hljs-number">0xf3f3f3</span>,</span><br><span class="line">  autoDensity: <span class="hljs-literal">true</span>,</span><br><span class="line">  resolution: <span class="hljs-built_in">window</span>.devicePixelRatio,</span><br><span class="line">  antialias: <span class="hljs-literal">true</span>,</span><br><span class="line">  autoStart: <span class="hljs-literal">true</span>,</span><br><span class="line">  resizeTo: container,</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">container.append(renderer.view);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> g = <span class="hljs-keyword">new</span> PIXI.Graphics();</span><br><span class="line">stage.addChild(g);</span><br><span class="line">g.lineStyle(<span class="hljs-number">1</span>);</span><br><span class="line">g.moveTo(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);</span><br><span class="line">g.lineTo(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>);</span><br></pre></td></tr></tbody></table></figure><p></p>
<!--
finishPoly -> drawShape -> graphicsData
updateBatches + graphicsData -> buildDrawCalls
 -->
</body></html>
    
    </div>
    
    
    <div class="columns is-mobile is-multiline article-nav">
        <span class="column is-12-mobile is-half-desktop is-hidden-mobile article-nav-prev">
            
        </span>
        <span class="column is-12-mobile is-half-desktop  article-nav-next">
            
            <a href="/2021/02/09/%E4%BD%BF%E7%94%A8RxJS%E5%AE%9E%E7%8E%B0%E5%BF%AB%E6%8D%B7%E9%94%AE/">使用RxJS实现快捷键</a>
            
        </span>
    </div>
    
</article>




    </div>
</section>
    <footer class="footer">
    <div class="container">
        <div class="columns content">
            <div class="column is-narrow has-text-centered">
                &copy; 2021 Defpis&nbsp;
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
            </div>
            <div class="column is-hidden-mobile"></div>

            
            <div class="column is-narrow">
                <div class="columns is-mobile is-multiline is-centered">
                    
                    
                    <a class="column is-narrow has-text-black" title="GitHub"
                        href="https://github.com/defpis">
                        
                        GitHub
                        
                    </a>
                    
                </div>
            </div>
            
            
        </div>
    </div>
</footer>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script>

<!-- test if the browser is outdated -->
<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/" target="_blank" rel="noopener">Update my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/outdated-browser/1.1.5/outdatedbrowser.min.js"></script>
<script>
    $(document).ready(function () {
        // plugin function, place inside DOM ready function
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        })
    });
</script>

<script>
    window.FontAwesomeConfig = {
        searchPseudoElements: true
    }
    moment.locale("zh-CN");
</script>


    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script>
    MathJax.Hub.Config({
        "HTML-CSS": {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
</script>

    
    
    
    
<script src="//cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.8/js/lightgallery-all.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/justifiedGallery/3.6.5/js/jquery.justifiedGallery.min.js"></script>
<script>
    (function ($) {
        $(document).ready(function () {
            if (typeof($.fn.lightGallery) === 'function') {
                $('.article.gallery').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof($.fn.justifiedGallery) === 'function') {
                $('.justified-gallery').justifiedGallery();
            }
        });
    })(jQuery);
</script>

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
    <style>
        .hljs {
            position: relative;
        }

        .hljs .clipboard-btn {
            float: right;
            color: #9a9a9a;
            background: none;
            border: none;
            cursor: pointer;
        }

        .hljs .clipboard-btn:hover {
          color: #8a8a8a;
        }

        .hljs > .clipboard-btn {
            display: none;
            position: absolute;
            right: 4px;
            top: 4px;
        }

        .hljs:hover > .clipboard-btn {
            display: inline;
        }

        .hljs > figcaption > .clipboard-btn {
            margin-right: 4px;
        }
    </style>
    <script>
      $(document).ready(function () {
        $('figure.hljs').each(function(i, figure) {
          var codeId = 'code-' + i;
          var code = figure.querySelector('.code');
          var copyButton = $('<button>Copy <i class="far fa-clipboard"></i></button>');
          code.id = codeId;
          copyButton.addClass('clipboard-btn');
          copyButton.attr('data-clipboard-target-id', codeId);

          var figcaption = figure.querySelector('figcaption');

          if (figcaption) {
            figcaption.append(copyButton[0]);
          } else {
            figure.prepend(copyButton[0]);
          }
        })

        var clipboard = new ClipboardJS('.clipboard-btn', {
          target: function(trigger) {
            return document.getElementById(trigger.getAttribute('data-clipboard-target-id'));
          }
        });
        clipboard.on('success', function(e) {
          e.clearSelection();
        })
      })
    </script>

    
    

    



<script src="/js/script.js"></script>


    
    <div class="searchbox ins-search">
    <div class="searchbox-mask"></div>
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="站内搜索" />
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: '文章',
                PAGES: '页面',
                CATEGORIES: '分类',
                TAGS: '标签',
                UNTITLED: '(无标题)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>

<script src="/js/insight.js"></script>

    
</body>
</html>